<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <link rel="stylesheet" href="main.css" />
  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #video {
      position: fixed;
      left: 0;
      bottom: 0;
    }

    #blocker1 {
      position: absolute;
      text-align: center;
      width: 100%;
      height: 100%;
      padding-left: 10%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
    }

    #blocker {
      position: absolute;
      text-align: center;
      width: 100%;
      height: 100%;
      padding-left: 10%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    #secondBlocker {
      position: absolute;
      font-family: "Comic Sans MS", "Comic Sans", cursive;
      width: 88%;
      height: 5%;
      margin: 5%;
      margin-top: 0.5%;
      font-size: 2.5vh;
      text-align: center;
      color: #ffffffcc;
      background-color: rgba(0, 0, 0, 0);
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      pointer-events: none;
    }
  </style>
  <title>Alien Base</title>
</head>

<body>
  <div id="container"></div>

  <div id="aiming1"><img src="img/aiming4.png" width="19px" height="19px"></div>
  <div id="secondBlocker" style="display: none">

  </div>
  <div id="blocker1"></div>
  <div id="blocker">
    <div id="content">
      <h1>Alien Base</h1>
      <p>
        We humans are obsessed with the idea that we’re not alone, that somewhere out there in the universe, there are
        other life forms intelligent enough to communicate with us.<br>
        But if there is life out there, why haven’t we heard from them yet?
      <p>Or have we?</p>
      </p>
      <a class="btn" onclick="hideMe()">START EXPLORATION</a><br>
      <!--<a class="btn1" onclick="goSolar()">Go Solar</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="btn1" onclick="goIsland()">Go Island</a>-->

    </div>
  </div>
</body>

<script src="./three.js/build/three.js"></script>
<script src="./JS/jquery.js"></script>
<script src="./JS/stats.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
  varying vec3 vNormal;
  varying vec3 vPositionNormal;
  void main() 
  {
    vNormal = normalize( normalMatrix * normal );
    vPositionNormal = normalize(( modelViewMatrix * vec4(position, 1.0) ).xyz);
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
</script>
<!-- fragment shader a.k.a. pixel shader -->
<script id="fragmentShader" type="x-shader/x-vertex">
  uniform vec3 glowColor;
  uniform float b;
  uniform float p;
  uniform float s;
  varying vec3 vNormal;
  varying vec3 vPositionNormal;
  void main() 
  {
    float a = pow( b + s * abs(dot(vNormal, vPositionNormal)), p );
    gl_FragColor = vec4( glowColor, a );
  }
</script>

<script type="module">
  import {
    Lensflare,
    LensflareElement,
  } from "./three.js/examples/jsm/objects/Lensflare.js";
  import { OBJLoader } from './three.js/examples/jsm/loaders/OBJLoader.js';
  import { MTLLoader } from './three.js/examples/jsm/loaders/MTLLoader.js';
  import { GUI } from './three.js/examples/jsm/libs/dat.gui.module.js'
  import { Water } from './three.js/examples/jsm/objects/Water.js';

  var FPS = 60;
  var singleFrameTime = (1 / FPS);
  var timeStamp = 0;
  var fps_speed = 120 / FPS;


  var scene;
  var camera;
  var renderer;
  var rotatespeed = 5 * fps_speed;
  var stats = new Stats();
  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
  document.body.appendChild(stats.dom);
  var star_radius = new Array();

  var add_solar = false;
  var add_city = true;
  var add_base = true;
  var moveForward = false;
  var moveBackward = false;
  var moveLeft = false;
  var moveRight = false;
  var jump = false;
  var fast = false;
  var esc = true;
  var speedup = false;
  var speeddown = false;
  var meteorites = [];
  var gotoground = false;
  var arrived = 50;
  var ufo_scale = 10;

  var distance_to_protection = 500;

  var shield_color_red = new THREE.Color(1, 0.5, 0.5);
  var shield_color_blue = new THREE.Color(0xeeffff);
  var spotLight;
  var vec = new THREE.Vector3();
  var start_point = new THREE.Vector3(0, 0, 0);
  var last_position = start_point.clone().set(-131.66, -465, 1296.76);
  var cameraPosition = vec.clone().set(-131.66, -465, 1296.76);
  var cameraDirection = vec.clone().set(0, 0, 0);
  var hit_direction = vec.clone().set(0, 0, 0);
  var hit_frame = 0;
  var catchspeed = 0;
  var ufo_starlight = 0.06;
  var tranfer_speed = 1;
  var t_in = true;
  var chasing = vec.clone();
  var chaseing_frame = 50;
  var safe_dis = 2.25;
  var hit_open = true;

  var SEPARATION = 250,
    AMOUNTX = 12,
    AMOUNTY = 4,
    AMOUNTZ = 12;
  var particles,
    particle,
    star_d,
    star_d_speed,
    star_s_speed,
    count = 0;

  var city1;
  var angle = 0;

  // Mouse Move
  var delta = 0;
  var mouseP = { x: 0, y: 0 };
  var up = 0;
  var down = 0;
  var left = 0;
  var right = 0;

  var maxSpeed = 0.025 * fps_speed;
  var acc = 0.2 * fps_speed;
  var currentSpeedForward = 0;
  var currentSpeedRight = 0;
  var Forward = true;
  var Right = true;
  const clock = new THREE.Clock();
  var angleX = 0;
  var angleY = 0;
  var angleZX = 0;
  var angleZY = 0;
  var scaling = false;

  var speed = 1;
  var obj3d = new THREE.Object3D();
  var all_obj = obj3d.clone();
  var all_obj1 = obj3d.clone();
  var all_obj2 = obj3d.clone();
  var all_obj3 = obj3d.clone();
  var all_obj4 = obj3d.clone();
  var color = new THREE.Color();

  const raycaster = new THREE.Raycaster();
  const raycaster1 = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  var selected_object = false;


  var env_light = new THREE.AmbientLight(0x282930);
  const sunlight = new THREE.TextureLoader().load("img/lensflare2.png");

  const ufolight = new THREE.TextureLoader().load("img/ufo_light1.png");



  const starball = new THREE.TextureLoader().load("img/ball.png");
  var meteoriteball = new THREE.TextureLoader().load("img/star0.png");
  var meteoritetail = new THREE.TextureLoader().load("img/start0.png");

  var meteoriteballr = new THREE.TextureLoader().load("img/star00.png");
  var meteoritetailr = new THREE.TextureLoader().load("img/start00.png");

  var textureFlare0 = new THREE.TextureLoader().load(
    "img/lensflare0.png"
  );
  var textureFlare0a = new THREE.TextureLoader().load(
    "img/lensflare0a.png"
  );
  var textureFlare0b = new THREE.TextureLoader().load(
    "img/lensflare0b.png"
  );



  var material = new THREE.Sprite(new THREE.SpriteMaterial({
    transparent: true,
    blending: THREE.AdditiveBlending,
    map: meteoriteball,
    color: 0xffffff,
    depthTest: true,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -10
  }));
  var materialr = new THREE.Sprite(new THREE.SpriteMaterial({
    transparent: true,
    blending: THREE.AdditiveBlending,
    map: meteoriteballr,
    color: 0xffffff,
    depthTest: true,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -10
  }));
  var material1 = new THREE.Sprite(new THREE.SpriteMaterial({
    transparent: true,
    blending: THREE.AdditiveBlending,
    map: meteoritetail,
    color: 0xffffff,
    depthTest: true,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -10
  }));

  var material1r = new THREE.Sprite(new THREE.SpriteMaterial({
    transparent: true,
    blending: THREE.AdditiveBlending,
    map: meteoritetailr,
    color: 0xffffff,
    depthTest: true,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -10
  }));

  var meteorite_Object3D = obj3d.clone();
  var ufo = meteorite_Object3D.clone();
  var village = meteorite_Object3D.clone();
  scene = new THREE.Scene();

  const waterGeometry = new THREE.CircleGeometry(5000, 100);

  var MeshWater = new Water(
    waterGeometry,
    {
      textureWidth: 1024,
      textureHeight: 1024,
      waterNormals: new THREE.TextureLoader().load('./three.js/examples/textures/waternormals.jpg', function (texture) {

        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

      }),
      sunDirection: new THREE.Vector3(),
      sunColor: 0xffffff,
      waterColor: 0x001e1f,
      distortionScale: 3,
      fog: scene.fog !== undefined
    }, 0.6
  );
  const ju_map = new THREE.TextureLoader().load("./texture/ju.jpg");
  var jupiter_m = new THREE.MeshBasicMaterial({
    map: ju_map,
    transparent: true,
    opacity: 0.75
  }
  )
  var jupiter = new THREE.Mesh(new THREE.PlaneGeometry(2500, 2500), jupiter_m)
  jupiter.name = "jupiter"
  const normalMap2 = new THREE.TextureLoader().load("./three.js/examples/textures/water/Water_1_M_Normal.jpg");
  const clearcoatNormaMap = new THREE.TextureLoader().load("./three.js/examples/textures/pbr/Scratched_gold/Scratched_gold_01_1K_Normal.png");

  var ufo_material = new THREE.MeshPhysicalMaterial({
    clearcoat: 1.0,
    metalness: 1.0,
    color: 0xffffff,
    normalMap: normalMap2,
    normalScale: new THREE.Vector2(0.05, 0.05),
    clearcoatNormalMap: clearcoatNormaMap,

    // y scale is negated to compensate for normal map handedness.
    clearcoatNormalScale: new THREE.Vector2(1.0, - 1.0)
  });

  var shield_uniforms =
  {
    "s": { type: "f", value: -0.75 },
    "b": { type: "f", value: 0.5 },
    "p": { type: "f", value: 3 },
    glowColor: { type: "c", value: shield_color_blue }
  };
  var customMaterial = new THREE.ShaderMaterial({
    uniforms: shield_uniforms,
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent,
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending,
    transparent: true
  })

  function init() {

    var skyGeometry = new THREE.SphereGeometry(8000, 100, 100);
    var map = new THREE.TextureLoader().load('img/bg5.png');
    map.wrapS = THREE.RepeatWrapping;
    map.wrapT = THREE.RepeatWrapping;
    map.repeat.set(15, 15);

    var skyBox = new THREE.Mesh(skyGeometry, new THREE.MeshBasicMaterial({
      map: map,
      side: THREE.BackSide,
    }));
    skyBox.name = "Sky"
    scene.add(skyBox);

    camera = new THREE.PerspectiveCamera(
      42, // fov 45 degree
      window.innerWidth / window.innerHeight, //aspect (width/height ratio)
      10, //near
      10000 // far
    );

    particles = new Array();
    star_d = new Array();
    star_d_speed = new Array();
    star_s_speed = new Array();
    var material = new THREE.SpriteMaterial({
      transparent: true,
      blending: THREE.AdditiveBlending,
      map: starball,
      color: 0xffffff,
    });
    var littlestar = new THREE.Sprite(material);
    littlestar.renderOrder = 2
    var i = 0;
    for (var ix = 0; ix < AMOUNTX; ix++) {
      for (var iy = 0; iy < AMOUNTY; iy++) {
        for (var iz = 0; iz < AMOUNTZ; iz++) {
          particle = particles[i] = littlestar.clone();
          star_d[i] = vec.clone().set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
          star_d_speed[i] = vec.clone().set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
          star_s_speed[i] = Math.random() - 0.5;
          i++;
          particle.position.x = ix * SEPARATION - (AMOUNTX * SEPARATION) / 2 + ((Math.random() - 0.5) * SEPARATION * 16);
          particle.position.y = iy * SEPARATION / 2 + ((Math.random() - 0.5) * SEPARATION * 16);
          particle.position.z = iz * SEPARATION - (AMOUNTZ * SEPARATION) / 2 + ((Math.random() - 0.5) * SEPARATION * 16);
          scene.add(particle);
        }
      }
    }








    var geometryGround = new THREE.CircleBufferGeometry(5000, 100, 100);
    geometryGround.rotateX(Math.PI / 2);
    geometryGround.translate(0, 0, 0);
    var texture = THREE.ImageUtils.loadTexture("texture/pattern5.jpg");
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(500, 500);
    var materialGround = new THREE.MeshStandardMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    var MeshGround = new THREE.Mesh(geometryGround, materialGround);
    MeshGround.position.set(0, -510, 0)
    MeshGround.name = "Ground";
    MeshGround.receiveShadow = true;
    MeshGround.castShadow = false;
    all_obj4.add(MeshGround);




    MeshWater.rotation.x = - Math.PI / 2;
    MeshWater.position.set(0, -504, 0)
    MeshWater.name = "Water";
    MeshWater.receiveShadow = true;
    MeshWater.castShadow = false;
    all_obj4.add(MeshWater);



    camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
    camera.lookAt(cameraDirection.x, cameraDirection.y, cameraDirection.z);

    scene.add(camera);

    document.addEventListener("mousemove", mouseMove, false);

    var onKeyDown = function (e) {
      switch (e.keyCode) {
        case 87:
        case 38:
          moveForward = true;
          selected_object = false;
          break;

        case 83:
        case 40:
          moveBackward = true;
          selected_object = false;
          break;

        case 65:
        case 37:
          moveLeft = true;
          selected_object = false;
          break;

        case 68:
        case 39:
          moveRight = true;
          selected_object = false;
          break;

        case 16:
          fast = true;
          break;

        case 27:
          esc = true;
          $("#blocker").fadeIn(1000);
          $("#content").fadeIn(1000);
          break;

        case 69:
          speedup = true;
          break;

        case 81:
          speeddown = true;
          break;

      }
    };

    var onKeyUp = function (e) {
      switch (e.keyCode) {
        case 87:
        case 38:
          moveForward = false;
          break;

        case 83:
        case 40:
          moveBackward = false;
          break;

        case 65:
        case 37:
          moveLeft = false;
          break;

        case 68:
        case 39:
          moveRight = false;
          break;

        case 16:
          fast = false;
          break;

        case 69:
          speedup = false;
          break;

        case 81:
          speeddown = false;
          break;


      }
    };

    document.addEventListener("keydown", onKeyDown, false);
    document.addEventListener("keyup", onKeyUp, false);

    scene.add(env_light);



    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById("container").appendChild(renderer.domElement);
    document.body.appendChild(renderer.domElement);
    const mtlLoader = new MTLLoader();
    mtlLoader.load('UFO2/UFO2.mtl', (mtl) => {
      mtl.preload();
      const objLoader = new OBJLoader();
      objLoader.setMaterials(mtl);
      objLoader.load('UFO2/UFO2.obj', (root) => {
        for (var k in root.children) {
          root.children[k].castShadow = true;
        }
        root.position.set(0, 0, 0);
        root.scale.set(0.1, 0.1, 0.1);
        var ufo_light_material = new THREE.SpriteMaterial({
          blending: THREE.AdditiveBlending,
          map: ufolight,
          transparent: true,
          opacity: 0.5
        });
        var ufo_light = new THREE.Sprite(ufo_light_material);
        ufo_light.renderOrder = 2
        var ufo_top_light = new THREE.Mesh(new THREE.SphereGeometry(0.085, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffee }));
        var white_light = littlestar.clone();
        white_light.renderOrder = 2

        var ring_m = new THREE.MeshPhongMaterial({ color: 0xFF51AA, specular: 0xFF51AA, side: THREE.DoubleSide, emissive: 0xFF51AA });
        var ufo_ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.0909 * 5, 0.0025, 3, 144, Math.PI / 5.455), ring_m);
        ufo_ring1.rotation.x = Math.PI / 2;
        ufo_ring1.rotation.z = Math.PI / 15.35;
        ufo_ring1.position.y = 0.021 * 5;
        var ufo_ring2 = new THREE.Mesh(new THREE.TorusGeometry(0.092 * 5, 0.0025, 3, 144, Math.PI / 5.455), ring_m);
        ufo_ring2.rotation.x = Math.PI / 2;
        ufo_ring2.rotation.z = Math.PI / 9.35 + Math.PI / 3;
        ufo_ring2.position.y = 0.021 * 5;
        var ufo_ring3 = new THREE.Mesh(new THREE.TorusGeometry(0.09095 * 5, 0.0025, 3, 144, Math.PI / 5.455), ring_m);
        ufo_ring3.rotation.x = Math.PI / 2;
        ufo_ring3.rotation.z = Math.PI / 8.65 + Math.PI * 2 / 3;
        ufo_ring3.position.y = 0.021 * 5;
        var ufo_ring4 = new THREE.Mesh(new THREE.TorusGeometry(0.09085 * 5, 0.0025, 3, 144, Math.PI / 5.455), ring_m);
        ufo_ring4.rotation.x = Math.PI / 2;
        ufo_ring4.rotation.z = Math.PI / 10.65 + Math.PI;
        ufo_ring4.position.y = 0.021 * 5;
        var ufo_ring5 = new THREE.Mesh(new THREE.TorusGeometry(0.09085 * 5, 0.0025, 3, 144, Math.PI / 5.455), ring_m);
        ufo_ring5.rotation.x = Math.PI / 2;
        ufo_ring5.rotation.z = Math.PI / 13.65 + Math.PI * 4 / 3;
        ufo_ring5.position.y = 0.021 * 5;
        var ufo_ring6 = new THREE.Mesh(new THREE.TorusGeometry(0.09085 * 5, 0.0025, 3, 144, Math.PI / 4.655), ring_m);
        ufo_ring6.rotation.x = Math.PI / 2;
        ufo_ring6.rotation.z = Math.PI / 18.65 + Math.PI * 5 / 3;
        ufo_ring6.position.y = 0.021 * 5;

        var ufo_ring0 = new THREE.Mesh(new THREE.TorusGeometry(0.0566 * 5, 0.06, 3, 72), new THREE.MeshPhongMaterial({ color: 0x44E0FF, specular: 0x44E0FF, side: THREE.DoubleSide, emissive: 0x44E0FF }));
        ufo_top_light.position.set(0, 0.033 * 5, 0);
        white_light.position.set(0, 0.036 * 5, 0);
        white_light.scale.set(0.063 * 5, 0.0525 * 5);
        ufo_light.position.set(0, -0.04, 0);
        ufo_light.scale.set(0.05, 0.25);


        var light_for_ufo = new THREE.PointLight(0xffffee, 0.5, 100 * ufo_scale / 10, 0.75);
        light_for_ufo.penumbra = 0.1;
        light_for_ufo.castShadow = true;
        light_for_ufo.shadow.mapSize.width = 1024;
        light_for_ufo.shadow.mapSize.height = 1024;
        light_for_ufo.shadow.camera.far = 100 * ufo_scale / 10;
        light_for_ufo.shadow.camera.near = 0.1 * ufo_scale / 10;
        light_for_ufo.shadow.radius = 3
        light_for_ufo.shadowBias = -0.001;

        light_for_ufo.position.set(0, 0.3, 0);

        var light_for_ufo1 = new THREE.PointLight(0xffffee, 1.5, 30 * ufo_scale / 10, 0.95);
        light_for_ufo1.penumbra = 0.1;
        light_for_ufo1.castShadow = true;
        light_for_ufo1.shadow.mapSize.width = 1024;
        light_for_ufo1.shadow.mapSize.height = 1024;
        light_for_ufo1.shadow.camera.far = 30 * ufo_scale / 10;
        light_for_ufo1.shadow.camera.near = 0.1 * ufo_scale / 10;
        light_for_ufo1.shadow.radius = 3
        light_for_ufo1.shadowBias = -0.001;

        light_for_ufo1.position.set(0, 0, 0);


        var ufo_ball = new THREE.Mesh(new THREE.SphereGeometry(0.18, 30, 30), new THREE.MeshPhongMaterial({ color: 0xFFFFFF, specular: 0xFFFFFF, emissive: 0xFFFFFF, transparent: true, opacity: 0.95 }));
        ufo_ball.scale.y = 0.1;
        ufo_ball.position.y = 0.065;
        ufo_ring0.rotation.x = Math.PI / 2;
        ufo_ring0.position.y = 0.0222 * 5;


        root.children[2].material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
        root.children[3].material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
        root.children[5].material = ufo_material
        ufo.add(root);
        ufo.add(ufo_light);
        ufo.add(ufo_top_light);
        ufo.add(white_light);
        ufo.add(ufo_ring1);
        ufo.add(ufo_ring2);
        ufo.add(ufo_ring3);
        ufo.add(ufo_ring4);
        ufo.add(ufo_ring5);
        ufo.add(ufo_ring6);
        ufo.add(ufo_ring0);

        ufo.add(light_for_ufo);
        ufo.add(light_for_ufo1);
        ufo.add(ufo_ball);

        ufo.position.z -= 0.48 * 5;
        ufo.position.y -= 0.12 * 5;

      });
    });
    ufo.scale.set(ufo_scale, ufo_scale, ufo_scale);
    scene.add(ufo);
    ufo.position.set(0, -1000, 0);



    // var citylight1 = light_loader("obj/light3/light3", "obj/light3/light3", 0.5, true);
    // citylight1.position.set(0, -512, 0);
    // citylight1.rotation.y = Math.PI;
    // citylight1.name = "citylight1";
    // if (add_base) all_obj2.add(citylight1);
    // all_obj2.position.y += 50;

    var big_light = obj3d.clone();
    var Cylinder1 = new THREE.Mesh(new THREE.CylinderGeometry(4.65, 5, 1, 50), new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0xFFFFFF, emissive: 0xffffff, transparent: true, opacity: 0.95 }));
    var light_white1 = new THREE.PointLight(0xffffff, 0.3, 700 * 1/*ufo_scale/100*/);
    light_white1.penumbra = 0.3;
    light_white1.castShadow = true;
    light_white1.shadow.mapSize.width = 1024;
    light_white1.shadow.mapSize.height = 1024;
    light_white1.shadow.camera.far = 700 * 1/*ufo_scale/100*/;
    light_white1.shadow.camera.near = 5 * 1/*ufo_scale/100*/;
    light_white1.shadowBias = -0.001;
    light_white1.shadow.radius = 3
    light_white1.position.y = 4;
    big_light.add(light_white1);
    big_light.add(Cylinder1)


    var new_light8 = big_light.clone();
    new_light8.position.set(-78.35, -373.4, 133.85);
    new_light8.scale.set(3.5, 5.3, 3.5);
    if (add_base) all_obj2.add(new_light8);

    var new_light9 = big_light.clone();
    new_light9.position.set(67.45, -373.4, 133.85);
    new_light9.scale.set(3.5, 5.3, 3.5);
    if (add_base) all_obj2.add(new_light9);

    var new_light10 = big_light.clone();
    new_light10.position.set(-82.5, -215.15, -47.75);
    new_light10.scale.set(2.5, 6.2, 2.5);
    if (add_base) all_obj2.add(new_light10);

    var new_light11 = big_light.clone();
    new_light11.position.set(69.25, -215.15, -47.75);
    new_light11.scale.set(2.5, 6.2, 2.5);
    if (add_base) all_obj2.add(new_light11);

    var new_light12 = big_light.clone();
    new_light12.position.set(82.1, -400.6, -196.4);
    new_light12.scale.set(9.5, 6.2, 9.5);
    if (add_base) all_obj2.add(new_light12);

    city1 = obj_loader("obj/city2/city2", "obj/city2/city2", 1.5, true);
    city1.position.set(21.5, -560, 499);
    city1.name = "city1";
    if (add_base) all_obj2.add(city1);
    all_obj2.position.y += 50;


    var protection_texture = THREE.ImageUtils.loadTexture("texture/shield4.png");
    protection_texture.wrapS = THREE.RepeatWrapping;
    protection_texture.wrapT = THREE.RepeatWrapping;
    protection_texture.repeat.set(500, 500);
    var protection_material = new THREE.MeshPhongMaterial({
      color: 0xeeffff,
      map: protection_texture,
      transparent: true,
      opacity: 1,
      side: THREE.DoubleSide,
      shininess: 0
    });
    var protection = new THREE.Mesh(new THREE.SphereGeometry(499.5, 100, 100), protection_material);

    protection.position.y = -560
    protection.scale.y = 1.6
    protection.renderOrder = 1
    protection.name = "protection"
    all_obj3.add(protection);

    var protection1 = new THREE.Mesh(new THREE.SphereGeometry(500, 100, 100), customMaterial);

    protection1.position.y = -560
    protection1.scale.y = 1.6
    protection1.renderOrder = 1
    protection1.name = "protection"
    all_obj3.add(protection1);

    // var blue_light = new THREE.Mesh(new THREE.CylinderGeometry(4.65, 4.5, 1, 50), new THREE.MeshPhongMaterial({ color: 0x54a1b2, specular: 0xFFFFFF, emissive: 0x54a1b2, transparent: true, opacity: 0.95 }));

    // var new_light3 = blue_light.clone();
    // new_light3.position.set(-0.4, -273.1, 51);
    // new_light3.scale.set(0.77, 3.5, 0.77);
    // if(add_base)all_obj2.add(new_light3);

    // var new_light4 = blue_light.clone();
    // new_light4.position.set(-4.1, -370.9, 197.05);
    // new_light4.scale.set(1.2, 3.6, 1.2);
    // if(add_base)all_obj2.add(new_light4);

    // var new_light5 = blue_light.clone();
    // new_light5.position.set(-155.35, -366.4, 82.5);
    // new_light5.scale.set(1.2, 3.6, 1.2);
    // if(add_base)all_obj2.add(new_light5);

    // var new_light6 = blue_light.clone();
    // new_light6.position.set(151.25, -366.4, 82.5);
    // new_light6.scale.set(1.2, 3.6, 1.2);
    // if(add_base)all_obj2.add(new_light6);

    // var new_light7 = blue_light.clone();
    // new_light7.position.set(-0.2, -143.45, -31.65);
    // new_light7.scale.set(1.2, 3.6, 1.2);
    // if(add_base)all_obj2.add(new_light7);
    jupiter.position.set(0, 4000, -6500)
    //jupiter.rotation.z=Math.PI/4
    jupiter.rotation.x = Math.PI / 7
    scene.add(jupiter)


    all_obj2.position.y -= 20;

    all_obj.add(all_obj1);
    all_obj.add(all_obj2);
    all_obj.add(all_obj3);
    all_obj.add(all_obj4);
    all_obj.scale.set(1/*ufo_scale/100*/, 1/*ufo_scale/100*/, 1/*ufo_scale/100*/);
    scene.add(all_obj);




    // const gui = new GUI()
    // const cubeFolder = gui.addFolder("new_light12")
    // cubeFolder.add(new_light12.position, "x", 50, 120, 0.05)
    // cubeFolder.add(new_light12.position, "y", -450, -400, 0.05)
    // cubeFolder.add(new_light12.position, "z", -250, -150, 0.05)

    // cubeFolder.add(new_light12.scale, "x", 0.5, 10, 0.01)
    // cubeFolder.add(new_light12.scale, "y", 0.5, 10, 0.01)
    // cubeFolder.add(new_light12.scale, "z", 0.5, 10, 0.01)
    // cubeFolder.add(new_light12.children[0].position, "y", 0.5, 30, 0.01)

    //  cubeFolder.open()
  }
  init();


  function obj_loader(url, url1, scale, double = true) {
    var newobj = obj3d.clone();
    var newmtl = new MTLLoader();
    if (double) { newmtl.setMaterialOptions({ side: THREE.DoubleSide }) }
    newmtl.load(url1 + '.mtl', (mtl) => {
      mtl.preload();
      var objLoader = new OBJLoader();
      objLoader.setMaterials(mtl);
      objLoader.load(url + '.obj', (root) => {
        for (var k = 0; k < root.children.length; k++) {
          root.children[k].castShadow = true;
          root.children[k].receiveShadow = true;
        }
        root.children[1].material = new THREE.MeshPhongMaterial({ color: 0x54a1b2, specular: 0xFFFFFF, emissive: 0x54a1b2, side: THREE.DoubleSide, transparent: true, opacity: 0.95 })
        // root.children[2].material = new THREE.MeshPhongMaterial({ color: 0x66686b, specular: 0xFFFFFF, emissive: 0x66686b, side: THREE.DoubleSide, transparent: true, opacity: 0.95 })

        root.position.set(0, 0, 0);
        root.scale.set(scale, scale, scale);
        newobj.add(root);
      });
    });
    return newobj;
  }


  function light_loader(url, url1, scale, double = false) {
    var newobj = obj3d.clone();
    var newmtl = new MTLLoader();
    newmtl.load(url1 + '.mtl', (mtl) => {
      mtl.preload();
      const objLoader = new OBJLoader();
      objLoader.setMaterials(mtl);
      objLoader.load(url + '.obj', (root) => {
        var object = root;
        for (var k in root.children) {
          root.children[k].castShadow = true;
          root.children[k].receiveShadow = true;
        }

        var Cylinder = new THREE.Mesh(new THREE.CylinderGeometry(32, 32, 32, 3), new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0xFFFFFF, emissive: 0xffffff, transparent: true, opacity: 0.95 }));
        Cylinder.rotation.y = Math.PI / 3;
        Cylinder.position.set(0, 225, 1.925);
        var light_white = new THREE.PointLight(0xffffff, 1, 1000 * scale);
        light_white.position.set(0, 225, 1.925);
        light_white.penumbra = 0.3;
        light_white.castShadow = true;
        light_white.shadow.mapSize.width = 1024;
        light_white.shadow.mapSize.height = 1024;
        light_white.shadow.camera.far = 1000 * scale * 1/*ufo_scale/100*/;
        light_white.shadow.camera.near = 32 * scale * 1/*ufo_scale/100*/;
        light_white.shadow.radius = 3
        light_white.shadowBias = -0.001;
        object.position.set(0, 0, 0);
        object.scale.set(0.2, 0.2, 0.2);
        //newobj.add(object);
        newobj.add(light_white);
        newobj.add(Cylinder);
        newobj.scale.set(scale, scale, scale);
      });
    });
    return newobj;
  }


  function obj_lighting(url, size, x, y, z, name) {
    var startTexture = THREE.ImageUtils.loadTexture(url);
    var starBall = new THREE.Mesh(
      new THREE.SphereGeometry(size, 100, 100),
      new THREE.MeshStandardMaterial({
        emissive: 0xffffff,
        emissiveMap: startTexture,
      })
    );
    star_radius[name] = size;
    starBall.position.set(x, y, z);
    return starBall;
  }
  function obj(url, size, x, y, z, name) {
    var startTexture = THREE.ImageUtils.loadTexture(url);
    var starBall = new THREE.Mesh(
      new THREE.SphereGeometry(size, 50, 50),
      new THREE.MeshStandardMaterial({
        map: startTexture,
        transparent: true,
        opacity: 0.4
      })
    );
    star_radius[name] = size;
    starBall.position.set(x, y, z);
    return starBall;
  }

  function ring1(url, size, width, x, y, z) {
    var startTexture = THREE.ImageUtils.loadTexture(url);
    var starBall = new THREE.Mesh(
      new THREE.RingGeometry(size, size + width, size * 10),
      new THREE.MeshStandardMaterial({
        map: startTexture,
        side: THREE.DoubleSide,
      })
    );
    starBall.rotation.x = -Math.PI / 2;
    starBall.rotation.y = -Math.PI / 12;
    starBall.position.set(x, y, z);
    return starBall;
  }
  function ring2(url, size, width, x, y, z) {
    var startTexture = THREE.ImageUtils.loadTexture(url);
    var starBall = new THREE.Mesh(
      new THREE.RingGeometry(size, size + width, size * 10),
      new THREE.MeshStandardMaterial({
        map: startTexture,
        side: THREE.DoubleSide,
      })
    );
    starBall.rotation.x = -Math.PI / 2;
    starBall.rotation.y = -Math.PI / 6;
    starBall.position.set(x, y, z);
    return starBall;
  }


  function getMousePosition() {
    var x = document.getElementById("aiming1").offsetLeft + 10;
    var y = document.getElementById("aiming1").offsetTop + 10;
    return { x: x, y: y };
  }
  function mouseMove(e) {

    mouse.x = ((document.getElementById("aiming1").offsetLeft + 10) / window.innerWidth) * 2 - 1;
    mouse.y = - ((document.getElementById("aiming1").offsetTop + 10) / window.innerHeight) * 2 + 1;



    document.getElementById("aiming1").style.left = e.clientX - 10 + "px";
    document.getElementById("aiming1").style.top = e.clientY - 10 + "px";
    if (esc)
      var mouseP = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    else var mouseP = getMousePosition();
    if (mouseP["y"] / window.innerHeight < 0.50) {
      up = 0.50 - mouseP["y"] / window.innerHeight;
    } else {
      up = 0;
    }
    if (mouseP["y"] / window.innerHeight > 0.62) {
      down = mouseP["y"] / window.innerHeight - 0.62;
    } else {
      down = 0;
    }
    if (mouseP["x"] / window.innerWidth < 0.47) {
      left = 0.47 - mouseP["x"] / window.innerWidth;
    } else {
      left = 0;
    }
    if (mouseP["x"] / window.innerWidth > 0.53) {
      right = mouseP["x"] / window.innerWidth - 0.53;
    } else {
      right = 0;
    }
  }


  function bounder_detect() {
    var distance = Math.sqrt(cameraPosition.x * cameraPosition.x + cameraPosition.z * cameraPosition.z) - 1500
    var dir = vec.clone().set(0 - cameraPosition.x, 0, 0 - cameraPosition.z).normalize()
    if (distance > 0) {
      selected_object = false;
      cameraPosition.z += distance * dir.z
      cameraPosition.x += distance * dir.x
    }
    // cameraPosition.x = Math.max(-1500, Math.min(1500, cameraPosition.x));
    // cameraPosition.z = Math.max(-1500, Math.min(1500, cameraPosition.z));
    cameraPosition.y = Math.max(-508 + 0.55 * ufo_scale, Math.min(1200, cameraPosition.y));
    if (cameraPosition.y > 500) {
      selected_object = false;
      document.getElementById("blocker1").style.backgroundColor = "rgba(0, 0, 0, 1)";
      $("#blocker1").fadeIn(2500);
      setTimeout(function () { window.location.href = "solar.html"; }, 3500);

    }
    //  if (crash_detect(ufo, sun, "sun") && crash_detect(ufo, star1, "star1") && crash_detect(ufo, star2, "star2") && crash_detect(ufo, star3, "star3") && crash_detect(ufo, starlite3, "starlite3") && crash_detect(ufo, star4, "star4") && crash_detect(ufo, star5, "star5") && crash_detect(ufo, star6, "star6") && crash_detect(ufo, starlite6, "starlite6") && crash_detect(ufo, star7, "star7") && crash_detect(ufo, star8, "star8") && crash_detect(ufo, star9, "star9")) return false;
    //  else return true;
  }
  function crash_detect(a, b, i) {
    if (hit_frame > 450) return true;
    if (star_radius[i] + 2 > a.position.distanceTo(b.position)) {
      hit_direction.set(a.position.x - b.position.x, a.position.y - b.position.y, a.position.z - b.position.z).normalize();
      return false;
    }
    else {
      return true;
    }
  }

  function hit_detect() {
    distance_to_protection = 500
    if (!hit_open) return false;
    var detect_obj = [all_obj3]
    raycaster.near = 0.1;
    raycaster.far = 550;
    var local = vec.clone().set(ufo.position.x, ufo.position.y + 0.2 * ufo_scale, ufo.position.z);
    var all_direct1 = [vec.clone().set(-ufo.position.x, 0, -ufo.position.z)];
    for (var i = 0; i < all_direct1.length; i++) {
      raycaster.set(local, all_direct1[i].normalize());
      var hit_face = raycaster.intersectObjects(detect_obj, true);
      if (hit_face.length > 0) {
        if (hit_face[0].object.name == "protection" && hit_face[0].distance < distance_to_protection) { distance_to_protection = hit_face[0].distance }
        if (hit_face[0].distance < 0.45 * ufo_scale) {
          hit_direction.set(local.x - hit_face[0].point.x, local.y - hit_face[0].point.y, local.z - hit_face[0].point.z);
          return true;
        };
      }
    }
    var all_direct2 = [vec.clone().set(0, 1, 0), vec.clone().set(0, -1, 0)];
    for (var i = 0; i < all_direct2.length; i++) {
      raycaster.set(local, all_direct2[i].normalize());
      var hit_face = raycaster.intersectObjects(detect_obj, true);
      if (hit_face.length > 0) {
        if (hit_face[0].object.name == "protection" && hit_face[0].distance < distance_to_protection) { distance_to_protection = hit_face[0].distance }
        if (hit_face[0].distance < 0.2 * ufo_scale) {
          hit_direction.set(local.x - hit_face[0].point.x, local.y - hit_face[0].point.y, local.z - hit_face[0].point.z);
          return true;
        };
      }
    }
    return false;
  }

  function onMouseClick(event) {
    if (document.getElementById("content").style.display == "none" && !esc) {
      raycaster1.setFromCamera(mouse, camera);
      raycaster1.near = 0.1;
      raycaster1.far = 10000;
      var intersects = raycaster1.intersectObjects(scene.children, true);
      for (var i = 0; i < intersects.length; i++) { if (intersects[i].object.type != "Sprite" && intersects[i].object.name != "ring" && intersects[i].object.name != "Sky") break; }
      if (i < intersects.length) {
        arrived = 50;
        selected_object = intersects[i];
        catchspeed = 0;
        t_in = true;
      }
      else {
        selected_object = false;
        t_in = false;
      }
    }
  }

  window.addEventListener('mousedown', onMouseClick, false);


  function operation_method_1(delta) {
    bounder_detect()
    if (hit_detect()) {
      hit_frame = 500;
      chaseing_frame = 0;
    };
    if (hit_frame > 0) {
      moveForward = moveLeft = moveRight = moveBackward = false;
      currentSpeedForward = 0;
      currentSpeedRight = 0;
      cameraPosition.x += hit_direction.x * hit_frame * rotatespeed / 100000;
      cameraPosition.y += hit_direction.y * hit_frame * rotatespeed / 100000;
      cameraPosition.z += hit_direction.z * hit_frame * rotatespeed / 100000;


      ufo.rotation.x = Math.cos(hit_frame * Math.PI / 7) * (hit_frame / 3000);
      ufo.rotation.z = Math.sin(hit_frame * Math.PI / 7) * (hit_frame / 3000);
      ufo.children[1].scale.set(0, 0);
      ufo.children[1].material.opacity = 0;
      ufo.children[1].position.y = 0.15;

      ufo.children[10].material.color.set(0xff2222);
      ufo.children[10].material.specular.set(0xff2222);
      ufo.children[10].material.emissive.set(0xff2222);

      hit_frame -= fps_speed;
      speed = -speed / 20 + speed;
      selected_object = false;
    }
    else {
      ufo.rotation.x = 0;
      ufo.children[10].material.color.set(0x44E0FF);
      ufo.children[10].material.specular.set(0x44E0FF);
      ufo.children[10].material.emissive.set(0x44E0FF);
    }
    if (document.getElementById("content").style.display == "none"
    ) {
      esc = false;
    }
    if (fast) maxSpeed = 0.06 * fps_speed;
    else maxSpeed = Math.max(maxSpeed - 0.001 * fps_speed, 0.025 * fps_speed);

    if ((moveForward || moveBackward || moveRight || moveLeft) && !fast) {
      ufo.children[1].scale.y = (0.4 - ufo.children[1].scale.y) / 50 * fps_speed + ufo.children[1].scale.y;
      ufo.children[1].material.opacity = (0.8 - ufo.children[1].material.opacity) / 50 * fps_speed + ufo.children[1].material.opacity;
      ufo.children[1].position.y = (-0.09 - ufo.children[1].position.y) / 50 * fps_speed + ufo.children[1].position.y;
      speed = (2 - speed) / 50 + speed;
    }
    else if ((moveForward || moveBackward || moveRight || moveLeft) && fast) {
      ufo.children[1].scale.y = (0.6 - ufo.children[1].scale.y) / 50 * fps_speed + ufo.children[1].scale.y;
      ufo.children[1].material.opacity = (0.95 - ufo.children[1].material.opacity) / 50 * fps_speed + ufo.children[1].material.opacity;
      ufo.children[1].position.y = (-0.15 - ufo.children[1].position.y) / 50 * fps_speed + ufo.children[1].position.y;
      speed = (4 - speed) / 50 + speed;
    }
    else {
      ufo.children[1].scale.y = (0.25 - ufo.children[1].scale.y) / 50 * fps_speed + ufo.children[1].scale.y;
      ufo.children[1].material.opacity = (0.7 - ufo.children[1].material.opacity) / 50 * fps_speed + ufo.children[1].material.opacity;
      ufo.children[1].position.y = (-0.04 - ufo.children[1].position.y) / 50 * fps_speed + ufo.children[1].position.y;
      speed = (1 - speed) / 50 + speed;
    }
    // Mouse Move

    if (moveForward && !moveBackward) {
      if (!Forward && currentSpeedForward != 0) {
        cameraPosition.z -= cameraDirection.z * currentSpeedForward;
        cameraPosition.y -= cameraDirection.y * currentSpeedForward;
        cameraPosition.x -= cameraDirection.x * currentSpeedForward;
        currentSpeedForward = Math.max(0, currentSpeedForward - delta * acc);
      } else {
        cameraPosition.z += cameraDirection.z * currentSpeedForward;
        cameraPosition.y += cameraDirection.y * currentSpeedForward;
        cameraPosition.x += cameraDirection.x * currentSpeedForward;
        currentSpeedForward = Math.min(
          maxSpeed,
          currentSpeedForward + delta * acc
        );
        Forward = true;
      }
    } else if (moveBackward && !moveForward) {
      if (Forward && currentSpeedForward != 0) {
        cameraPosition.z += cameraDirection.z * currentSpeedForward;
        cameraPosition.y += cameraDirection.y * currentSpeedForward;
        cameraPosition.x += cameraDirection.x * currentSpeedForward;
        currentSpeedForward = Math.max(0, currentSpeedForward - delta * acc);
      } else {
        cameraPosition.z -= cameraDirection.z * currentSpeedForward;
        cameraPosition.y -= cameraDirection.y * currentSpeedForward;
        cameraPosition.x -= cameraDirection.x * currentSpeedForward;
        currentSpeedForward = Math.min(
          maxSpeed,
          currentSpeedForward + delta * acc
        );
        Forward = false;
      }
    }

    if (moveRight && !moveLeft) {
      if (!Right && currentSpeedRight != 0) {
        cameraPosition.x += cameraDirection.z * currentSpeedRight;
        cameraPosition.z -= cameraDirection.x * currentSpeedRight;
        currentSpeedRight = Math.max(0, currentSpeedRight - delta * acc);
      } else {
        cameraPosition.x -= cameraDirection.z * currentSpeedRight;
        cameraPosition.z += cameraDirection.x * currentSpeedRight;
        currentSpeedRight = Math.min(
          maxSpeed,
          currentSpeedRight + delta * acc
        );
        Right = true;
      }
    } else if (moveLeft && !moveRight) {
      if (Right && currentSpeedRight != 0) {
        cameraPosition.x -= cameraDirection.z * currentSpeedRight;
        cameraPosition.z += cameraDirection.x * currentSpeedRight;
        currentSpeedRight = Math.max(0, currentSpeedRight - delta * acc);
      } else {
        cameraPosition.x += cameraDirection.z * currentSpeedRight;
        cameraPosition.z -= cameraDirection.x * currentSpeedRight;
        currentSpeedRight = Math.min(
          maxSpeed,
          currentSpeedRight + delta * acc
        );
        Right = false;
      }
    }
    if ((!moveBackward && !moveForward) || (moveBackward && moveForward)) {
      if (Forward) {
        cameraPosition.z += cameraDirection.z * currentSpeedForward;
        cameraPosition.y += cameraDirection.y * currentSpeedForward;
        cameraPosition.x += cameraDirection.x * currentSpeedForward;
        currentSpeedForward = Math.max(0, currentSpeedForward - delta * acc);
      } else {
        cameraPosition.z -= cameraDirection.z * currentSpeedForward;
        cameraPosition.y -= cameraDirection.y * currentSpeedForward;
        cameraPosition.x -= cameraDirection.x * currentSpeedForward;
        currentSpeedForward = Math.max(0, currentSpeedForward - delta * acc);
      }
    }
    if ((!moveRight && !moveLeft) || (moveRight && moveLeft)) {
      if (Right) {
        cameraPosition.x -= cameraDirection.z * currentSpeedRight;
        cameraPosition.z += cameraDirection.x * currentSpeedRight;
        currentSpeedRight = Math.max(0, currentSpeedRight - delta * acc);
      } else {
        cameraPosition.x += cameraDirection.z * currentSpeedRight;
        cameraPosition.z -= cameraDirection.x * currentSpeedRight;
        currentSpeedRight = Math.max(0, currentSpeedRight - delta * acc);
      }
    }

    angleX += (left / 15 / Math.PI - right / 15 / Math.PI) * fps_speed;
    cameraDirection.x -= Math.sin(angleX);
    cameraDirection.z -= Math.cos(angleX);

    if (cameraDirection.y < 0.85 * ufo_scale && !scaling) {
      angleY += (up / 600 / Math.PI) * fps_speed * ufo_scale * Math.sqrt(ufo_scale);
    }
    if (cameraDirection.y > -0.8 * ufo_scale && !scaling) {
      angleY -= (down / 500 / Math.PI) * fps_speed * ufo_scale * Math.sqrt(ufo_scale);
    }
    //console.log(angleY)
    cameraDirection.y = (Math.sin(angleY) * 100) / ufo_scale;
    cameraDirection.setLength(2.4 * ufo_scale);



    if (arrived > 0 && selected_object && document.getElementById("content").style.display == "none") {
      //console.log(selected_object.point)
      safe_dis = 2 * ufo_scale;
      chaseing_frame = 50;
      ufo.children[10].material.color.set(0xFFFF33);
      ufo.children[10].material.specular.set(0xFFFF33);
      ufo.children[10].material.emissive.set(0xFFFF33);
      catchspeed = Math.min(catchspeed + 0.01 * fps_speed, 1.2 * fps_speed)


      var distance = Math.sqrt(selected_object.point.x * selected_object.point.x + selected_object.point.z * selected_object.point.z) - 1500
      var dir = vec.clone().set(0 - selected_object.point.x, 0, 0 - selected_object.point.z).normalize()
      if (distance > 0) {
        var z = selected_object.point.z + distance * dir.z
        var x = selected_object.point.x + distance * dir.x
      } else {
        var z = selected_object.point.z
        var x = selected_object.point.x
      }

      var delx = x - cameraPosition.x;
      var dely = selected_object.point.y - cameraPosition.y;
      var delz = z - cameraPosition.z;
      var di = vec.clone().set(delx, dely, delz).normalize();
      chasing.set(delx - di.x * safe_dis, dely - di.y * safe_dis, delz - di.z * safe_dis);
      if (chasing.distanceTo(start_point) < 100) { t_in = false; }
      if (t_in) {
        ufo_starlight = Math.min(ufo_starlight + 0.0002 * fps_speed, 0.08);
        ufo.children[3].scale.set(ufo_starlight * 5, ufo_starlight * 25 / 6);
        ufo.children[11].intensity = ufo_starlight * 20 - 0.5;
        ufo.children[12].intensity = ufo_starlight * 20 + 1;
        ufo.children[1].scale.y = (0.9 - ufo.children[1].scale.y) / 50 * fps_speed + ufo.children[1].scale.y;
        ufo.children[1].material.opacity = (1 - ufo.children[1].material.opacity) / 50 * fps_speed + ufo.children[1].material.opacity;
        ufo.children[1].position.y = (-0.2 - ufo.children[1].position.y) / 50 * fps_speed + ufo.children[1].position.y;
        tranfer_speed = Math.min(tranfer_speed + 1 * fps_speed, 10 / speed);
      } else {
        ufo_starlight = Math.max(ufo_starlight - 0.0002 * fps_speed, 0.06);
        ufo.children[3].scale.set(ufo_starlight * 5, ufo_starlight * 25 / 6);
        ufo.children[11].intensity = ufo_starlight * 20 - 0.5;
        ufo.children[12].intensity = ufo_starlight * 20 + 1;
        ufo.children[1].scale.y = (0.25 - ufo.children[1].scale.y) / 100 * fps_speed + ufo.children[1].scale.y;
        ufo.children[1].material.opacity = (0.7 - ufo.children[1].material.opacity) / 100 * fps_speed + ufo.children[1].material.opacity;
        ufo.children[1].position.y = (-0.04 - ufo.children[1].position.y) / 100 * fps_speed + ufo.children[1].position.y;
        tranfer_speed = Math.max(tranfer_speed - 0.1 * fps_speed, 1);
        arrived -= 1;
      }
      if (chasing.distanceTo(vec.clone().set(0, 0, 0)) > 500) chasing.setLength(500)
      cameraPosition.x += chasing.x * catchspeed / 50;
      cameraPosition.y += chasing.y * catchspeed / 50;
      cameraPosition.z += chasing.z * catchspeed / 50;



    }
    else {
      if (hit_frame <= 0) {
        ufo.children[10].material.color.set(0x44E0FF);
        ufo.children[10].material.specular.set(0x44E0FF);
        ufo.children[10].material.emissive.set(0x44E0FF);
        cameraPosition.x += (chasing.x) * catchspeed / 2500 * chaseing_frame;
        cameraPosition.y += (chasing.y) * catchspeed / 2500 * chaseing_frame;
        cameraPosition.z += (chasing.z) * catchspeed / 2500 * chaseing_frame;
        if (chaseing_frame > 0) chaseing_frame -= fps_speed;
        else chaseing_frame = 0;
      }
      ufo_starlight = Math.max(ufo_starlight - 0.0002 * fps_speed, 0.06);
      ufo.children[3].scale.set(ufo_starlight * 5, ufo_starlight * 25 / 6);
      ufo.children[11].intensity = ufo_starlight * 20 - 0.5;
      ufo.children[12].intensity = ufo_starlight * 20 + 1;
      ufo.children[1].scale.set((0.05 - ufo.children[1].scale.x) / 100 * fps_speed + ufo.children[1].scale.x, (0.25 - ufo.children[1].scale.y) / 100 + ufo.children[1].scale.y);
      ufo.children[1].material.opacity = (0.7 - ufo.children[1].material.opacity) / 100 * fps_speed + ufo.children[1].material.opacity;
      ufo.children[1].position.y = (-0.04 - ufo.children[1].position.y) / 100 * fps_speed + ufo.children[1].position.y;
      tranfer_speed = Math.max(tranfer_speed - 0.1 * fps_speed, 1);
    }

    var follow = 1
    //ufo.position.set((cameraPosition.x-ufo.position.x)/follow+ufo.position.x, (cameraPosition.y-ufo.position.y)/follow+ufo.position.y, (cameraPosition.z-ufo.position.z)/follow+ufo.position.z);
    ufo.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z)
    ufo.rotation.y += 0.01 / Math.PI * speed * tranfer_speed * fps_speed;
    ufo.position.y += Math.sin(count * 60) * 0.01 * speed * ufo_scale;

    //camera.position.set(cameraPosition.x - cameraDirection.x, cameraPosition.y - cameraDirection.y + 0.6 * ufo_scale, cameraPosition.z - cameraDirection.z);
    camera.position.set((cameraPosition.x - cameraDirection.x - camera.position.x) / follow + camera.position.x, (cameraPosition.y - cameraDirection.y + 0.6 * ufo_scale - camera.position.y) / follow + camera.position.y, (cameraPosition.z - cameraDirection.z - camera.position.z) / follow + camera.position.z);
    camera.lookAt(cameraPosition.x, cameraPosition.y + 0.6 * ufo_scale, cameraPosition.z);
  }






  function generate_meteoriteObject3D(size) {
    size = size * (Math.random() * 0.6 + 0.7)
    var osize = size;

    var meteoriteObject3D = meteorite_Object3D.clone();


    var x, y, z;
    x = (Math.random() - 0.5) * 8000;
    y = Math.random() * 4000 - 500;
    z = Math.sqrt(7999 * 7999 - x * x - y * y) * (Math.random() > 0.5 ? 1 : -1);


    var v1 = vec.clone().set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
    while ((v1.y < 0 && y < 500) || vec.clone().set(-x, -y, -z).normalize().dot(v1) < 0.82 || vec.clone().set(-x, -y, -z).normalize().dot(v1) > 0.821 || (z < 0 && v1.z < 0)) {
      v1 = vec.clone().set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
    }
    var x1 = x;
    var y1 = y;
    var z1 = z;

    for (var i = 0; i < 2; i++) {
      if (i % 2 == 0) var meteorite = material.clone();
      else var meteorite = materialr.clone();
      meteorite.position.set(x - x1, y - y1, z - z1);
      meteorite.scale.set(size * 1.15, size * 1.15, 1)
      meteoriteObject3D.add(meteorite)
      x = x - size * v1.x / 3;
      y = y - size * v1.y / 3;
      z = z - size * v1.z / 3;
    }
    while (size > 1) {
      var meteorite = material.clone();
      var msize = Math.max(0.6, Math.pow(size / osize, 0.25));
      meteorite.scale.set(size * msize, size * msize, 1);
      meteorite.position.set(x - x1, y - y1, z - z1);
      meteoriteObject3D.add(meteorite)
      var meteorite = material1.clone();
      meteorite.scale.set(size, size, 1)
      meteorite.position.set(x - x1, y - y1, z - z1);
      meteoriteObject3D.add(meteorite)

      x = x - size * v1.x / 2.5;
      y = y - size * v1.y / 2.5;
      z = z - size * v1.z / 2.5;
      size *= 0.985;
    }
    meteoriteObject3D.position.set(x1, y1, z1);
    return [meteoriteObject3D, v1];

  }

  function meteorite_move(meteorite1) {
    if (meteorite1[0].position.distanceTo(start_point) > 8000) {
      scene.remove(meteorite1[0]);
      return true;
    }
    meteorite1[0].position.x += meteorite1[1].x * 3 * fps_speed;
    meteorite1[0].position.y += meteorite1[1].y * 3 * fps_speed;
    meteorite1[0].position.z += meteorite1[1].z * 3 * fps_speed;
    return false;
  }
















  function animate() {
    if (esc) {
      document.querySelector("body").style.cursor = 'url(./img/cursor.png),default';
      document.getElementById("aiming1").style.display = "none";
    }
    else {
      document.querySelector("body").style.cursor = "none";
      document.getElementById("aiming1").style.display = "block";
    }

    var delta = clock.getDelta();
    MeshWater.material.uniforms['time'].value += 1.0 / 180.0;
    requestAnimationFrame(animate);
    timeStamp += delta;
    if (timeStamp > singleFrameTime) {
      stats.update()
      if (meteorites.length < 5) {
        var meteorite1 = generate_meteoriteObject3D(10);
        meteorites.push(meteorite1);
        scene.add(meteorite1[0]);
      }
      for (var met in meteorites) {
        if (meteorite_move(meteorites[met])) meteorites.splice(met, 1);
      }

      var rotate = angle * Math.PI * rotatespeed;

      angle += 0.0005;
      //all_obj2.children[0].rotation.y -= 0.02

      //Ball Maving


      for (var i = 0; i < particles.length; i++) {
        particle = particles[i];
        particle.scale.x = particle.scale.y = Math.sin(star_s_speed[i] * count * 200) + 3;
        var d = star_d[i];
        var ds = star_d_speed[i];
        particle.position.x += d.x * Math.cos(ds.x * count) / 6;
        particle.position.y += d.y * Math.cos(ds.y * count) / 6;
        particle.position.z += d.z * Math.cos(ds.z * count) / 6;
      }
      count += 0.0005 * fps_speed;

      operation_method_1(delta);
      if (distance_to_protection >= 300) {
        // all_obj3.children[0].material.color.r=0.7
        // all_obj3.children[0].material.color.g=0.7
        // all_obj3.children[0].material.color.b=1
        // all_obj3.children[0].material.specular.r=0.7
        // all_obj3.children[0].material.specular.g=0.7
        // all_obj3.children[0].material.specular.b=1
        all_obj3.children[0].material.color.r = 0.9
        all_obj3.children[0].material.color.g = 0.9
        all_obj3.children[0].material.color.b = 1
        all_obj3.children[0].material.opacity = 1
        all_obj3.children[1].material.uniforms['glowColor'].value = shield_color_blue
        for (var i = 0; i < 5; i++) {
          all_obj2.children[i].children[0].color.r = 0.9
          all_obj2.children[i].children[0].color.g = 0.92
          all_obj2.children[i].children[0].color.b = 1
          if (i == 2 || i == 3) { all_obj2.children[i].children[0].intensity = 0.3 }
          else { all_obj2.children[i].children[0].intensity = 0.6 }
          all_obj2.children[i].children[1].material.color.r = 0.9
          all_obj2.children[i].children[1].material.color.g = 0.92
          all_obj2.children[i].children[1].material.color.b = 1

          all_obj2.children[i].children[1].material.emissive.r = 0.9
          all_obj2.children[i].children[1].material.emissive.g = 0.92
          all_obj2.children[i].children[1].material.emissive.b = 1
        }
        city1.children[0].children[1].material.color.r = 0.33
        city1.children[0].children[1].material.emissive.r = 0.33
        // city1.children[0].children[2].material.color.r = 0.3
        // city1.children[0].children[2].material.emissive.r = 0.3
        env_light.color.r = 0.10 / 1.5
        city1.children[0].children[1].material.color.g = 0.63
        city1.children[0].children[1].material.emissive.g = 0.63
        // city1.children[0].children[2].material.color.g = 0.6
        // city1.children[0].children[2].material.emissive.g = 0.6
        env_light.color.g = 0.11 / 1.5
        city1.children[0].children[1].material.color.b = 0.70
        city1.children[0].children[1].material.emissive.b = 0.70
        // city1.children[0].children[2].material.color.b = 0.65
        // city1.children[0].children[2].material.emissive.b = 0.65
        env_light.color.b = 0.13 / 1.5
        // for(var i=5;i<10;i++)
        // {
        //   all_obj2.children[i].material.emissive.r=0.475
        //   all_obj2.children[i].material.emissive.g=0.906
        //   all_obj2.children[i].material.emissive.b=1
        // }
      }
      else {
        // all_obj3.children[0].material.color.r=1
        // all_obj3.children[0].material.color.g=0.3
        // all_obj3.children[0].material.color.b=0.3
        // all_obj3.children[0].material.specular.r=1
        // all_obj3.children[0].material.specular.g=0
        // all_obj3.children[0].material.specular.b=0
        all_obj3.children[0].material.opacity = Math.abs(Math.sin(count * 4000)) * 0.36 + 0.64
        all_obj3.children[0].material.color.r = 1
        all_obj3.children[0].material.color.g = 0.3
        all_obj3.children[0].material.color.b = 0.3
        all_obj3.children[1].material.uniforms['glowColor'].value = shield_color_red
        var loop_red = Math.abs(Math.sin(count * 50)) * 0.6 + 0.2
        for (var i = 0; i < 5; i++) {
          all_obj2.children[i].children[0].color.r = 1 * loop_red
          all_obj2.children[i].children[0].color.g = 0.2 * loop_red
          all_obj2.children[i].children[0].color.b = 0.2 * loop_red
          if (i == 2 || i == 3) { all_obj2.children[i].children[0].intensity = 0.4 }
          else { all_obj2.children[i].children[0].intensity = 0.8 }

          all_obj2.children[i].children[1].material.color.r = 1 * loop_red
          all_obj2.children[i].children[1].material.color.g = 1 * loop_red
          all_obj2.children[i].children[1].material.color.b = 1 * loop_red

          all_obj2.children[i].children[1].material.emissive.r = 1 * loop_red
          all_obj2.children[i].children[1].material.emissive.g = 0.2 * loop_red
          all_obj2.children[i].children[1].material.emissive.b = 0.2 * loop_red
        }
        city1.children[0].children[1].material.color.r = 0.75 * loop_red
        city1.children[0].children[1].material.emissive.r = 0.75 * loop_red
        // city1.children[0].children[2].material.color.r = 0.4 * loop_red
        // city1.children[0].children[2].material.emissive.r = 0.4 * loop_red
        env_light.color.r = 0.1 * loop_red
        city1.children[0].children[1].material.color.g = 0.15 * loop_red
        city1.children[0].children[1].material.emissive.g = 0.15 * loop_red
        // city1.children[0].children[2].material.color.g = 0.08 * loop_red
        // city1.children[0].children[2].material.emissive.g = 0.08 * loop_red
        env_light.color.g = 0.08 * loop_red
        city1.children[0].children[1].material.color.b = 0.15 * loop_red
        city1.children[0].children[1].material.emissive.b = 0.15 * loop_red
        // city1.children[0].children[2].material.color.b = 0.08 * loop_red
        // city1.children[0].children[2].material.emissive.b = 0.08 * loop_red
        env_light.color.b = 0.08 * loop_red
        // for(var i=5;i<10;i++)
        // {
        //   all_obj2.children[i].material.emissive.r=0
        //   all_obj2.children[i].material.emissive.g=0
        //   all_obj2.children[i].material.emissive.b=0
        // }

      }
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);

      timeStamp = (timeStamp % singleFrameTime);
    }
  }

  animate();
  var MyResize = function () {
    //get the new sizes
    var width = window.innerWidth;
    var height = window.innerHeight;

    //then update the renderer
    renderer.setSize(width, height);
    //and update the aspect ratio of the camera
    camera.aspect = width / height;

    //update the projection matrix given the new values
    camera.updateProjectionMatrix();

    //and finally render the scene again
    renderer.render(scene, camera);
  };
  window.addEventListener("resize", MyResize);
</script>
<script>
  document.querySelector("body").style.cursor = 'url(./img/cursor.png),default';
  function hideMe() {
    $("#content").fadeOut(1000);
    $("#blocker").fadeOut(2000);
    $("#secondBlocker").delay(1200).fadeIn(1000);
  }
  function goSolar() {
    window.location.href = "solar.html"
  }
  function goIsland() {
    window.location.href = "island.html"
  }
</script>

</html>