<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="shortcut icon" href="img/galaxy.ico" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link rel="stylesheet" href="main.css" />
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #video {
        position: fixed;
        left: 0;
        bottom: 0;
      }

      #blocker {
        position: absolute;
        text-align: center;
        width: 100%;
        height: 100%;
        padding-left: 10%;
        background-color: rgba(0, 0, 0, 0.5);
      }

      #secondBlocker {
        position: absolute;
        font-family: "Comic Sans MS", "Comic Sans", cursive;
        width: 88%;
        height: 5%;
        margin: 5%;
        margin-top: 0.5%;
        font-size: 2.5vh;
        text-align: center;
        color: #ffffffcc;
        background-color: rgba(0, 0, 0, 0);
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        pointer-events: none;
      }
      .loading {
        display: none;
        position: absolute;
        top: 48%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 99;
        color: white;
        font-size: 40px;
        font-weight: 100;
        font-family: Lato, sans-serif;
        letter-spacing: 10px;
        text-transform: uppercase;
        cursor: wait;
      }
      .loading span {
        animation: shrink 2s infinite;
      }

      @keyframes shrink {
        50% {
          transform: scale(0.2);
        }
      }
      #loading_background {
        position: absolute;
        background-color: rgb(0, 0, 0);
        z-index: 98;
        height: 100%;
        width: 100%;
        cursor: wait;
      }
    </style>
    <title>Planetary System</title>
  </head>

  <body>
    <div id="loading_background"></div>
    <div id="loading" class="loading">
      <span style="animation-delay: 0s">L</span
      ><span style="animation-delay: 0.1s">o</span
      ><span style="animation-delay: 0.2s">a</span
      ><span style="animation-delay: 0.3s">d</span
      ><span style="animation-delay: 0.4s">i</span
      ><span style="animation-delay: 0.5s">n</span
      ><span style="animation-delay: 0.6s">g</span
      ><span style="animation-delay: 0.7s">·</span
      ><span style="animation-delay: 0.8s">·</span
      ><span style="animation-delay: 0.9s">·</span>
    </div>
    <div id="container"></div>
    <div id="esc"></div>

    <div id="aiming1">
      <img src="img/aiming4.png" width="21px" height="21px" />
    </div>
    <div id="secondBlocker" style="display: none"></div>
    <div id="blocker">
      <div id="content">
        <h1>Explore the Solar</h1>
        <p id="para">
          Our solar system consists of our star, the Sun, and everything bound
          to it by gravity — the planets Mercury, Venus, Earth, Mars, Jupiter,
          Saturn, Uranus and Neptune, dwarf planets such as Pluto, dozens of
          moons and millions of asteroids, comets and meteoroids.
        <br>Go to the solar system, and explore its secrets!</p>
        <a class="btn" onclick="hideMe()">START EXPLORATION</a><br />
        <!--<a class="btn1" onclick="goIsland()">Go Island</a
        >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
          class="btn1"
          onclick="goAlianBase()"
          >Go Alian Base</a
        >-->
      </div>
    </div>
  </body>
  <script src="./JS/jquery.js"></script>
  <script>
    show_loading();

    function show_loading() {
      $("#loading").show();
      $("#loading").css({ display: "flex", opacity: 0 });
      $("#loading").animate({ opacity: 1 }, 500);
    }
    function hide_loading() {
      $("#loading").fadeOut(800);
      $("#loading_background").fadeOut(800);
    }
  </script>
  <script src="./three.js/build/three.js"></script>
  <!-- <script src="./JS/stats.min.js"></script> -->
  <script id="vertexShader" type="x-shader/x-vertex">
    uniform sampler2D noiseTexture;
    uniform float noiseScale;

    uniform sampler2D bumpTexture;
    uniform float bumpSpeed;
    uniform float bumpScale;

    uniform float time;
    uniform float bumpRepeat;
    uniform float noiseRepeat;

    varying vec2 vUv;

    void main()
    {
        vUv = uv;

      vec2 uvTimeShift = vUv + vec2( 1.1, 1.9 ) * time * bumpSpeed;
      vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift* vec2(noiseRepeat,noiseRepeat) );
      vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.g );
      // below, using uvTimeShift seems to result in more of a "rippling" effect
      //   while uvNoiseTimeShift seems to result in more of a "shivering" effect
      vec4 bumpData = texture2D( bumpTexture, uvTimeShift* vec2(bumpRepeat,bumpRepeat) );

      // move the position along the normal
      //  but displace the vertices at the poles by the same amount
      float displacement = ( vUv.y > 0.999 || vUv.y < 0.001 ) ?
        bumpScale * (0.3 + 0.02 * sin(time)) :
        bumpScale * bumpData.r;
        vec3 newPosition = position + normal * displacement;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-vertex">
    uniform sampler2D baseTexture;
    uniform float baseSpeed;
    uniform float repeatS;
    uniform float repeatT;

    uniform sampler2D noiseTexture;
    uniform float noiseScale;

    uniform sampler2D blendTexture;
    uniform float blendSpeed;
    uniform float blendOffset;

    uniform float time;
    uniform float alpha;

    uniform float noiseRepeat;

    varying vec2 vUv;

    void main()
    {
      vec2 uvTimeShift = vUv + vec2( -0.7, 1.5 ) * time * baseSpeed;
      vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift* vec2(noiseRepeat,noiseRepeat) );
      vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );
      vec4 baseColor = texture2D( baseTexture, uvNoiseTimeShift * vec2(repeatS, repeatT) );

      vec2 uvTimeShift2 = vUv + vec2( 1.3, -1.7 ) * time * blendSpeed;
      vec4 noiseGeneratorTimeShift2 = texture2D( noiseTexture, uvTimeShift2* vec2(noiseRepeat,noiseRepeat));
      vec2 uvNoiseTimeShift2 = vUv + noiseScale * vec2( noiseGeneratorTimeShift2.g, noiseGeneratorTimeShift2.b );
      vec4 blendColor = texture2D( blendTexture, uvNoiseTimeShift2 * vec2(repeatS, repeatT) ) - blendOffset * vec4(1.0, 1.0, 1.0, 1.0);

      vec4 theColor = baseColor + blendColor;
      theColor.a = alpha;
      gl_FragColor = theColor;
    }
  </script>
  <script type="module">
    import { OBJLoader } from "./three.js/examples/jsm/loaders/OBJLoader.js";
    import { MTLLoader } from "./three.js/examples/jsm/loaders/MTLLoader.js";
    import { GUI } from "./three.js/examples/jsm/libs/dat.gui.module.js";

    function go_alian_base() {
      document.getElementById("blocker").style.backgroundColor =
        "rgba(0, 0, 0, 1)";
      $("#blocker").fadeIn(2500);
      setTimeout(function () {
        window.location.href = "alian_base.html";
      }, 3500);
    }
    function go_island() {
      document.getElementById("blocker").style.backgroundColor =
        "rgba(0, 0, 0, 1)";
      $("#blocker").fadeIn(2500);
      setTimeout(function () {
        window.location.href = "island.html";
      }, 3500);
    }
    function go_lightning() {
      document.getElementById("blocker").style.backgroundColor =
        "rgba(0, 0, 0, 1)";
      $("#blocker").fadeIn(2500);
      setTimeout(function () {
        window.location.href = "lightning.html";
      }, 3500);
    }

    var follow_frame1 = 0;
    var follow_frame2 = 0;
    var follow_frame3 = 0;
    var FPS = 60;
    var singleFrameTime = 1 / FPS;
    var timeStamp = 0;
    var fps_speed = 120 / FPS;

    var scene;
    var camera;
    var renderer;
    var rotatespeed = 3 * fps_speed;
    //var stats = new Stats();
    //stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
    //document.body.appendChild(stats.dom);
    var star_radius = new Array();

    var add_solar = true;
    var add_city = true;
    var add_base = true;
    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;
    var jump = false;
    var fast = false;
    var esc = true;
    var speedup = false;
    var speeddown = false;
    var meteorites = [];
    var gotoground = false;
    var arrived = 50;
    var ufo_scale = 0.5;
    var load_items = 0;
    var loaded_items = 0;

    var color = new THREE.Color();
    var spotLight;
    var vec = new THREE.Vector3();
    var start_point = new THREE.Vector3(0, 0, 0);
    var last_position = start_point.clone().set(-131.66, -465, 1296.76);
    var cameraPosition = vec.clone().set(-131.66, 0, 1296.76);
    var cameraDirection = vec.clone().set(0, 0, 0);
    var hit_direction = vec.clone().set(0, 0, 0);
    var hit_frame = 0;
    var catchspeed = 0;
    var ufo_starlight = 0.06;
    var tranfer_speed = 1;
    var t_in = true;
    var chasing = vec.clone();
    var chaseing_frame = 50;
    var safe_dis = 2.25;
    var hit_open = false;
    var scaling = false;

    var SEPARATION = 140,
      AMOUNTX = 24,
      AMOUNTY = 8,
      AMOUNTZ = 24;
    var particles,
      particle,
      star_d,
      star_d_speed,
      star_s_speed,
      count = 0;

    var angle = 0;

    // Mouse Move
    var delta = 0;
    var mouseP = { x: 0, y: 0 };
    var up = 0;
    var down = 0;
    var left = 0;
    var right = 0;

    var maxSpeed = 0.3 * fps_speed;
    var acc = 3 * fps_speed;
    var currentSpeedForward = 0;
    var currentSpeedRight = 0;
    var Forward = true;
    var Right = true;
    const clock = new THREE.Clock();
    var angleX = 0;
    var angleY = 0;
    var angleZX = 0;
    var angleZY = 0;

    var speed = 1;
    var obj3d = new THREE.Object3D();
    var all_obj = obj3d.clone();
    var all_obj1 = obj3d.clone();
    var all_obj2 = obj3d.clone();
    var all_obj3 = obj3d.clone();
    var all_obj4 = obj3d.clone();

    const raycaster = new THREE.Raycaster();
    const raycaster1 = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    var selected_object = false;

    var lavaTexture = new THREE.ImageUtils.loadTexture("./texture/sun.jpg");
    lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
    // multiplier for distortion speed
    var baseSpeed = 0.025;
    // number of times to repeat texture in each direction
    var repeatS = 1.0;
    var repeatT = 1.0;

    // texture used to generate "randomness", distort all other textures
    var noiseTexture = new THREE.ImageUtils.loadTexture("texture/cloud.png");
    noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
    // magnitude of noise effect
    var noiseScale = 0.0025;

    // texture to additively blend with base image texture
    var blendTexture = new THREE.ImageUtils.loadTexture(
      "./texture/gstar-original.jpg"
    );
    blendTexture.wrapS = blendTexture.wrapT = THREE.RepeatWrapping;
    // multiplier for distortion speed
    var blendSpeed = 0.01;
    // adjust lightness/darkness of blended texture
    var blendOffset = 0.6;

    // texture to determine normal displacement
    var bumpTexture = noiseTexture;
    bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping;
    // multiplier for distortion speed
    var bumpSpeed = 0.025;
    // magnitude of normal displacement
    var bumpScale = 2.5;
    var noiseRepeat = 60;
    var bumpRepeat = 30;

    // use "this." to create global object
    var customUniforms = {
      baseTexture: { type: "t", value: lavaTexture },
      baseSpeed: { type: "f", value: baseSpeed },
      repeatS: { type: "f", value: repeatS },
      repeatT: { type: "f", value: repeatT },
      noiseRepeat: { type: "f", value: noiseRepeat },
      bumpRepeat: { type: "f", value: bumpRepeat },
      repeatT: { type: "f", value: repeatT },
      noiseTexture: { type: "t", value: noiseTexture },
      noiseScale: { type: "f", value: noiseScale },
      blendTexture: { type: "t", value: blendTexture },
      blendSpeed: { type: "f", value: blendSpeed },
      blendOffset: { type: "f", value: blendOffset },
      bumpTexture: { type: "t", value: bumpTexture },
      bumpSpeed: { type: "f", value: bumpSpeed },
      bumpScale: { type: "f", value: bumpScale },
      alpha: { type: "f", value: 1.0 },
      time: { type: "f", value: 1.0 },
    };

    // create custom material from the shader code above
    //   that is within specially labeled script tags
    var customMaterial = new THREE.ShaderMaterial({
      uniforms: customUniforms,
      vertexShader: document.getElementById("vertexShader").textContent,
      fragmentShader: document.getElementById("fragmentShader").textContent,
    });

    const sunlight = new THREE.TextureLoader().load("img/lensflare2.png");

    const ufolight = new THREE.TextureLoader().load("img/ufo_light1.png");

    if (add_solar) {
      var sunmaterial = new THREE.SpriteMaterial({
        blending: THREE.AdditiveBlending,
        map: sunlight,
        transparent: true,
        opacity: 0.1,
      });
      var sunbackground = new THREE.Sprite(sunmaterial);
      sunbackground.position.set(0, 0, 0);
      sunbackground.scale.set(500, 400, 1);
      var sunlight1 = new THREE.TextureLoader().load("img/ball.png");
      var sunmaterial1 = new THREE.SpriteMaterial({
        blending: THREE.AdditiveBlending,
        map: sunlight1,
        transparent: true,
        opacity: 0.1,
      });
      var sunbackground1 = new THREE.Sprite(sunmaterial1);
      sunbackground1.position.set(0, 0, 0);
      sunbackground1.scale.set(500, 400, 1);
      var sun = obj_lighting(
        "./texture/fluid1-original.png",
        100,
        0,
        0,
        0,
        "sun"
      );
      sun.material = customMaterial;
      var star1 = obj("./texture/j022.jpg", 4, 180, 0, 0, "star1");
      var star2 = obj("./texture/j028.jpg", 8, 240, 0, 0, "star2");
      var star3 = obj(
        "./three.js/examples/textures/land_ocean_ice_cloud_2048.jpg",
        10,
        320,
        0,
        0,
        "star3"
      );
      var starlite3 = obj(
        "./texture/j029.jpg",
        1,
        349,
        200 + 21,
        0,
        "starlite3"
      );
      var star4 = obj("./texture/saturnmap.jpg", 11, 780, 0, 0, "star4");
      var ring4 = ring1("./texture/ring1.png", 14, 15, 780, 0, 0);
      var star5 = obj("./texture/j006.jpg", 6, 420, 0, 0, "star5");
      var star6 = obj(
        "./texture/TDVC_Jupiter_Texture_Map.jpg",
        25,
        600,
        0,
        0,
        "star6"
      );
      var starlite6 = obj(
        "./texture/opura1.jpg",
        0.8,
        650,
        200 + 40,
        0,
        "starlite6"
      );
      var starlite61 = obj(
        "./texture/TDVC_Venus_Texture_Map.jpg",
        1.2,
        640,
        200 + 35,
        0,
        "starlite61"
      );
      var starlite62 = obj(
        "./texture/TDVC_Uranus_Moon_Texture_Map.jpg",
        1.3,
        655,
        200 + 45,
        0,
        "starlite62"
      );
      var starlite63 = obj(
        "./texture/j029.jpg",
        1.2,
        660,
        200 + 50,
        0,
        "starlite63"
      );
      var starlite64 = obj(
        "./texture/j019.jpg",
        1.5,
        665,
        200 + 55,
        0,
        "starlite64"
      );
      var starlite65 = obj(
        "./texture/j008.jpg",
        1.4,
        670,
        200 + 60,
        0,
        "starlite65"
      );
      var star7 = obj("./texture/uranus.JPG", 13, 900, 0, 0, "star7");
      var star8 = obj("./texture/j030.jpg", 8, 1050, 0, 0, "star8");
      var ring8 = ring2("./texture/ring2.png", 20, 2, 900, 0, 0);
      var star9 = obj("./texture/j033.jpg", 3, 1200, 0, 0, "star9");

      sun.name = "sun";
      star1.name = "star1";
      star2.name = "star2";
      star3.name = "star3";
      starlite3.name = "starlite3";
      star4.name = "star4";
      ring4.name = "ring";
      star5.name = "star5";
      star6.name = "star6";

      starlite61.name = "starlite61";
      starlite62.name = "starlite62";
      starlite63.name = "starlite63";
      starlite64.name = "starlite64";
      starlite65.name = "starlite65";
      starlite6.name = "starlite6";

      star7.name = "star7";
      star8.name = "star8";
      ring8.name = "ring";
      star9.name = "star9";

      var plant_name = [
        "sun",
        "star1",
        "star2",
        "star3",
        "starlite3",
        "star4",
        "star5",
        "star6",
        "starlite6",
        "starlite61",
        "starlite62",
        "starlite63",
        "starlite64",
        "starlite65",
        "star7",
        "star8",
        "star9",
      ];

      star1.castShadow = true;
      star2.castShadow = true;
      star3.castShadow = true;
      starlite3.castShadow = true;
      star4.castShadow = true;
      //ring4.castShadow = true;
      star5.castShadow = true;
      star6.castShadow = true;
      starlite6.castShadow = true;

      starlite61.castShadow = true;
      starlite62.castShadow = true;
      starlite63.castShadow = true;
      starlite64.castShadow = true;
      starlite65.castShadow = true;
      star7.castShadow = true;
      star8.castShadow = true;
      //ring8.castShadow = true;
      star9.castShadow = true;

      star1.receiveShadow = true;
      star2.receiveShadow = true;
      star3.receiveShadow = true;
      starlite3.receiveShadow = true;
      star4.receiveShadow = true;
      ring4.receiveShadow = true;
      star5.receiveShadow = true;
      star6.receiveShadow = true;
      starlite6.receiveShadow = true;
      starlite61.receiveShadow = true;
      starlite62.receiveShadow = true;
      starlite63.receiveShadow = true;
      starlite64.receiveShadow = true;
      starlite65.receiveShadow = true;
      star7.receiveShadow = true;
      star8.receiveShadow = true;
      ring8.receiveShadow = true;
      star9.receiveShadow = true;
    }

    const starball = new THREE.TextureLoader().load("img/ball.png");
    var meteoriteball = new THREE.TextureLoader().load("img/star0.png");
    var meteoritetail = new THREE.TextureLoader().load("img/start0.png");

    var meteoriteballr = new THREE.TextureLoader().load("img/star00.png");
    var meteoritetailr = new THREE.TextureLoader().load("img/start00.png");

    var textureFlare0 = new THREE.TextureLoader().load("img/lensflare0.png");
    var textureFlare0a = new THREE.TextureLoader().load("img/lensflare0a.png");
    var textureFlare0b = new THREE.TextureLoader().load("img/lensflare0b.png");
    if (add_solar) {
      var sunmaterial2 = new THREE.SpriteMaterial({
        map: textureFlare0a,
        transparent: true,
        opacity: 0.1,
      });
      var sunbackground2 = new THREE.Sprite(sunmaterial2);
      sunbackground2.position.set(0, 0, 0);
      sunbackground2.scale.set(600, 600, 0.1);
      var sunmaterial3 = new THREE.SpriteMaterial({
        map: textureFlare0b,
        transparent: true,
        opacity: 0.1,
      });
      var sunbackground3 = new THREE.Sprite(sunmaterial3);
      sunbackground3.position.set(0, 0, 0);
      sunbackground3.scale.set(900, 900, 0.1);
    }

    var material = new THREE.Sprite(
      new THREE.SpriteMaterial({
        transparent: true,
        blending: THREE.AdditiveBlending,
        map: meteoriteball,
        color: 0xffffff,
        depthTest: true,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -10,
      })
    );
    var materialr = new THREE.Sprite(
      new THREE.SpriteMaterial({
        transparent: true,
        blending: THREE.AdditiveBlending,
        map: meteoriteballr,
        color: 0xffffff,
        depthTest: true,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -10,
      })
    );
    var material1 = new THREE.Sprite(
      new THREE.SpriteMaterial({
        transparent: true,
        blending: THREE.AdditiveBlending,
        map: meteoritetail,
        color: 0xffffff,
        depthTest: true,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -10,
      })
    );

    var material1r = new THREE.Sprite(
      new THREE.SpriteMaterial({
        transparent: true,
        blending: THREE.AdditiveBlending,
        map: meteoritetailr,
        color: 0xffffff,
        depthTest: true,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -10,
      })
    );

    var meteorite_Object3D = obj3d.clone();
    var ufo = meteorite_Object3D.clone();
    var village = meteorite_Object3D.clone();

    const normalMap2 = new THREE.TextureLoader().load(
      "./three.js/examples/textures/water/Water_1_M_Normal.jpg"
    );
    const clearcoatNormaMap = new THREE.TextureLoader().load(
      "./three.js/examples/textures/pbr/Scratched_gold/Scratched_gold_01_1K_Normal.png"
    );

    var ufo_material = new THREE.MeshPhysicalMaterial({
      clearcoat: 1.0,
      metalness: 1.0,
      color: 0xffffff,
      normalMap: normalMap2,
      normalScale: new THREE.Vector2(0.05, 0.05),
      clearcoatNormalMap: clearcoatNormaMap,

      // y scale is negated to compensate for normal map handedness.
      clearcoatNormalScale: new THREE.Vector2(1.0, -1.0),
    });

    function init() {
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById("container").appendChild(renderer.domElement);
      document.body.appendChild(renderer.domElement);
      scene = new THREE.Scene();
      var skyGeometry = new THREE.SphereGeometry(5000, 100, 100);
      var map = new THREE.TextureLoader().load("img/bg5.png");
      map.wrapS = THREE.RepeatWrapping;
      map.wrapT = THREE.RepeatWrapping;
      map.repeat.set(15, 15);

      var skyBox = new THREE.Mesh(
        skyGeometry,
        new THREE.MeshBasicMaterial({
          map: map,
          side: THREE.BackSide,
        })
      );
      skyBox.name = "Sky";
      scene.add(skyBox);

      camera = new THREE.PerspectiveCamera(
        42, // fov 45 degree
        window.innerWidth / window.innerHeight, //aspect (width/height ratio)
        0.1, //near
        10000 // far
      );

      particles = new Array();
      star_d = new Array();
      star_d_speed = new Array();
      star_s_speed = new Array();
      var material = new THREE.SpriteMaterial({
        transparent: true,
        blending: THREE.AdditiveBlending,
        map: starball,
        color: 0xffffff,
      });
      var littlestar = new THREE.Sprite(material);
      var i = 0;
      for (var ix = 0; ix < AMOUNTX; ix++) {
        for (var iy = 0; iy < AMOUNTY; iy++) {
          for (var iz = 0; iz < AMOUNTZ; iz++) {
            particle = particles[i] = littlestar.clone();
            star_d[i] = vec
              .clone()
              .set(
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
              );
            star_d_speed[i] = vec
              .clone()
              .set(
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
              );
            star_s_speed[i] = Math.random() - 0.5;
            i++;
            particle.position.x =
              ix * SEPARATION -
              (AMOUNTX * SEPARATION) / 2 +
              (Math.random() - 0.5) * SEPARATION * 16;
            particle.position.y =
              (iy * SEPARATION) / 2 -
              (AMOUNTY * SEPARATION) / 4 +
              (Math.random() - 0.5) * SEPARATION * 16;
            particle.position.z =
              iz * SEPARATION -
              (AMOUNTZ * SEPARATION) / 2 +
              (Math.random() - 0.5) * SEPARATION * 16;
            scene.add(particle);
          }
        }
      }

      camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
      camera.lookAt(cameraDirection.x, cameraDirection.y, cameraDirection.z);

      scene.add(camera);

      document.addEventListener("mousemove", mouseMove, false);

      var onKeyDown = function (e) {
        switch (e.keyCode) {
          case 87:
          case 38:
            moveForward = true;
            selected_object = false;
            break;

          case 83:
          case 40:
            moveBackward = true;
            selected_object = false;
            break;

          case 65:
          case 37:
            moveLeft = true;
            selected_object = false;
            break;

          case 68:
          case 39:
            moveRight = true;
            selected_object = false;
            break;

          case 16:
            fast = true;
            break;

          case 27:
            esc = true;
            $("#blocker").fadeIn(1200);
            $("#content").fadeIn(1200);
            $("#secondBlocker").fadeOut(600);
            break;

          case 69:
            speedup = true;
            break;

          case 81:
            speeddown = true;
            break;

          case 32:
            hit_open = !hit_open;
            break;
        }
      };

      var onKeyUp = function (e) {
        switch (e.keyCode) {
          case 87:
          case 38:
            moveForward = false;
            break;

          case 83:
          case 40:
            moveBackward = false;
            break;

          case 65:
          case 37:
            moveLeft = false;
            break;

          case 68:
          case 39:
            moveRight = false;
            break;

          case 16:
            fast = false;
            break;

          case 69:
            speedup = false;
            break;

          case 81:
            speeddown = false;
            break;
        }
      };

      document.addEventListener("keydown", onKeyDown, false);
      document.addEventListener("keyup", onKeyUp, false);

      scene.add(new THREE.AmbientLight(0x111111));
      if (add_solar) {
        const light = new THREE.PointLight(
          0xffeecc,
          1.5,
          2500 * 1 /*ufo_scale/100*/,
          2
        );
        light.position.set(0, 0, 0);
        light.penumbra = 0.3;
        light.castShadow = true;
        light.shadow.mapSize.width = 16384;
        light.shadow.mapSize.height = 16384;
        light.shadow.camera.far = 2500 * 1 /*ufo_scale/100*/;
        light.shadow.camera.near = 1 * 1 /*ufo_scale/100*/;
        all_obj4.add(light);

        all_obj4.add(sunbackground);
        all_obj4.add(sunbackground1);
        all_obj4.add(sunbackground2);
        all_obj4.add(sunbackground3);

        all_obj3.add(sun);
        all_obj3.add(star1);
        all_obj3.add(star2);
        all_obj3.add(star3);
        all_obj3.add(starlite3);
        all_obj3.add(star4);
        all_obj4.add(ring4);
        all_obj3.add(star5);
        all_obj3.add(star6);
        all_obj3.add(starlite6);

        all_obj3.add(starlite61);
        all_obj3.add(starlite62);
        all_obj3.add(starlite63);
        all_obj3.add(starlite64);
        all_obj3.add(starlite65);
        all_obj3.add(star7);
        all_obj3.add(star8);
        all_obj4.add(ring8);
        all_obj3.add(star9);
      }

      load_items += 2;
      let onProgress_obj = function (xhr) {
        if (xhr.lengthComputable) {
          let percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded(obj)");
          if (percentComplete == 100) {
            loaded_items += 1;
          }
        }
      };
      let onProgress_mtl = function (xhr) {
        if (xhr.lengthComputable) {
          let percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded(mtl)");
          if (percentComplete == 100) {
            loaded_items += 1;
          }
        }
      };

      const mtlLoader = new MTLLoader();
      mtlLoader.load(
        "UFO2/UFO2.mtl",
        (mtl) => {
          mtl.preload();
          const objLoader = new OBJLoader();
          objLoader.setMaterials(mtl);
          objLoader.load(
            "UFO2/UFO2.obj",
            (root) => {
              for (var k in root.children) {
                root.children[k].castShadow = true;
              }
              root.position.set(0, 0, 0);
              root.scale.set(0.1, 0.1, 0.1);
              var ufo_light_material = new THREE.SpriteMaterial({
                blending: THREE.AdditiveBlending,
                map: ufolight,
                transparent: true,
                opacity: 0.5,
              });
              var ufo_light = new THREE.Sprite(ufo_light_material);
              var ufo_top_light = new THREE.Mesh(
                new THREE.SphereGeometry(0.085, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xffffee })
              );
              var white_light = littlestar.clone();

              var ring_m = new THREE.MeshPhongMaterial({
                color: 0xff51aa,
                specular: 0xff51aa,
                side: THREE.DoubleSide,
                emissive: 0xff51aa,
              });
              var ufo_ring1 = new THREE.Mesh(
                new THREE.TorusGeometry(
                  0.0909 * 5,
                  0.0025,
                  3,
                  144,
                  Math.PI / 5.455
                ),
                ring_m
              );
              ufo_ring1.rotation.x = Math.PI / 2;
              ufo_ring1.rotation.z = Math.PI / 15.35;
              ufo_ring1.position.y = 0.021 * 5;
              var ufo_ring2 = new THREE.Mesh(
                new THREE.TorusGeometry(
                  0.092 * 5,
                  0.0025,
                  3,
                  144,
                  Math.PI / 5.455
                ),
                ring_m
              );
              ufo_ring2.rotation.x = Math.PI / 2;
              ufo_ring2.rotation.z = Math.PI / 9.35 + Math.PI / 3;
              ufo_ring2.position.y = 0.021 * 5;
              var ufo_ring3 = new THREE.Mesh(
                new THREE.TorusGeometry(
                  0.09095 * 5,
                  0.0025,
                  3,
                  144,
                  Math.PI / 5.455
                ),
                ring_m
              );
              ufo_ring3.rotation.x = Math.PI / 2;
              ufo_ring3.rotation.z = Math.PI / 8.65 + (Math.PI * 2) / 3;
              ufo_ring3.position.y = 0.021 * 5;
              var ufo_ring4 = new THREE.Mesh(
                new THREE.TorusGeometry(
                  0.09085 * 5,
                  0.0025,
                  3,
                  144,
                  Math.PI / 5.455
                ),
                ring_m
              );
              ufo_ring4.rotation.x = Math.PI / 2;
              ufo_ring4.rotation.z = Math.PI / 10.65 + Math.PI;
              ufo_ring4.position.y = 0.021 * 5;
              var ufo_ring5 = new THREE.Mesh(
                new THREE.TorusGeometry(
                  0.09085 * 5,
                  0.0025,
                  3,
                  144,
                  Math.PI / 5.455
                ),
                ring_m
              );
              ufo_ring5.rotation.x = Math.PI / 2;
              ufo_ring5.rotation.z = Math.PI / 13.65 + (Math.PI * 4) / 3;
              ufo_ring5.position.y = 0.021 * 5;
              var ufo_ring6 = new THREE.Mesh(
                new THREE.TorusGeometry(
                  0.09085 * 5,
                  0.0025,
                  3,
                  144,
                  Math.PI / 4.655
                ),
                ring_m
              );
              ufo_ring6.rotation.x = Math.PI / 2;
              ufo_ring6.rotation.z = Math.PI / 18.65 + (Math.PI * 5) / 3;
              ufo_ring6.position.y = 0.021 * 5;

              var ufo_ring0 = new THREE.Mesh(
                new THREE.TorusGeometry(0.0566 * 5, 0.06, 3, 72),
                new THREE.MeshPhongMaterial({
                  color: 0x44e0ff,
                  specular: 0x44e0ff,
                  side: THREE.DoubleSide,
                  emissive: 0x44e0ff,
                })
              );
              ufo_top_light.position.set(0, 0.033 * 5, 0);
              white_light.position.set(0, 0.036 * 5, 0);
              white_light.scale.set(0.063 * 5, 0.0525 * 5);
              ufo_light.position.set(0, -0.04, 0);
              ufo_light.scale.set(0.05, 0.25);

              var light_for_ufo = new THREE.PointLight(
                0xffffee,
                0.1,
                (100 * ufo_scale) / 200,
                0.75
              );
              light_for_ufo.penumbra = 0.1;
              // light_for_ufo.castShadow = true;
              // light_for_ufo.shadow.mapSize.width = 2048;
              // light_for_ufo.shadow.mapSize.height = 2048;
              // light_for_ufo.shadow.camera.far = (100 * ufo_scale) / 10;
              // light_for_ufo.shadow.camera.near = (0.1 * ufo_scale) / 10;

              light_for_ufo.position.set(0, 0.3, 0);

              var light_for_ufo1 = new THREE.PointLight(
                0xffffee,
                0.3,
                (30 * ufo_scale) / 60,
                0.95
              );
              light_for_ufo1.penumbra = 0.1;
              // light_for_ufo1.castShadow = true;
              // light_for_ufo1.shadow.mapSize.width = 2048;
              // light_for_ufo1.shadow.mapSize.height = 2048;
              // light_for_ufo1.shadow.camera.far = (30 * ufo_scale) / 10;
              // light_for_ufo1.shadow.camera.near = (0.1 * ufo_scale) / 10;

              light_for_ufo1.position.set(0, 0, 0);

              var ufo_ball = new THREE.Mesh(
                new THREE.SphereGeometry(0.18, 20, 20),
                new THREE.MeshPhongMaterial({
                  color: 0xffffff,
                  specular: 0xffffff,
                  emissive: 0xffffff,
                  transparent: true,
                  opacity: 0.95,
                })
              );
              ufo_ball.scale.y = 0.1;
              ufo_ball.position.y = 0.065;
              ufo_ring0.rotation.x = Math.PI / 2;
              ufo_ring0.position.y = 0.0222 * 5;
              root.children[2].material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
              });
              root.children[3].material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
              });
              root.children[5].material = ufo_material;
              ufo.add(root);
              ufo.add(ufo_light);
              ufo.add(ufo_top_light);
              ufo.add(white_light);
              ufo.add(ufo_ring1);
              ufo.add(ufo_ring2);
              ufo.add(ufo_ring3);
              ufo.add(ufo_ring4);
              ufo.add(ufo_ring5);
              ufo.add(ufo_ring6);
              ufo.add(ufo_ring0);

              ufo.add(light_for_ufo);
              ufo.add(light_for_ufo1);
              ufo.add(ufo_ball);

              ufo.position.z -= 0.48 * 5;
              ufo.position.y -= 0.12 * 5;
            },
            onProgress_obj
          );
        },
        onProgress_mtl
      );
      ufo.scale.set(ufo_scale, ufo_scale, ufo_scale);
      scene.add(ufo);
      ufo.position.set(0, -1000, 0);

      all_obj.add(all_obj1);
      all_obj.add(all_obj2);
      all_obj.add(all_obj3);
      all_obj.add(all_obj4);
      all_obj.scale.set(
        1 /*ufo_scale/100*/,
        1 /*ufo_scale/100*/,
        1 /*ufo_scale/100*/
      );
      scene.add(all_obj);
    }
    init();
    // var controls = new (function () {
    //   this.baseSpeed = 0.025;
    //   this.noiseRepeat=60;
    //   this.noiseScale = 0.0025;
    //   this.bumpSpeed = 0.025;
    //   this.bumpRepeat=30;
    //   this.bumpScale = 2.5;
    // })();
    // const gui = new GUI();
    // const sun_shader = gui.addFolder("shader");
    // sun_shader.add(controls, "baseSpeed", 0.02, 0.2);
    // sun_shader.add(controls, "noiseRepeat", 1, 100);
    // sun_shader.add(controls, "noiseScale", 0.002, 0.02);
    // sun_shader.add(controls, "bumpSpeed", 0.02, 0.5);
    // sun_shader.add(controls, "bumpRepeat", 1, 100);
    // sun_shader.add(controls, "bumpScale", 2, 20);

    // sun_shader.open();

    function obj_loader(url, url1, scale, double = false) {
      load_items += 2;
      let onProgress_obj = function (xhr) {
        if (xhr.lengthComputable) {
          let percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded(obj)");
          if (percentComplete == 100) {
            loaded_items += 1;
          }
        }
      };
      let onProgress_mtl = function (xhr) {
        if (xhr.lengthComputable) {
          let percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded(mtl)");
          if (percentComplete == 100) {
            loaded_items += 1;
          }
        }
      };
      var newobj = obj3d.clone();
      var newmtl = new MTLLoader();
      if (double) {
        newmtl.setMaterialOptions({ side: THREE.DoubleSide });
      }
      newmtl.load(
        url1 + ".mtl",
        (mtl) => {
          mtl.preload();
          var objLoader = new OBJLoader();
          objLoader.setMaterials(mtl);
          objLoader.load(
            url + ".obj",
            (root) => {
              for (var k = 0; k < root.children.length; k++) {
                root.children[k].castShadow = true;
                root.children[k].receiveShadow = true;
              }
              root.position.set(0, 0, 0);
              root.scale.set(scale, scale, scale);
              newobj.add(root);
            },
            onProgress_obj
          );
        },
        onProgress_mtl
      );
      return newobj;
    }

    function light_loader(url, url1, scale, double = false) {
      load_items += 2;
      let onProgress_obj = function (xhr) {
        if (xhr.lengthComputable) {
          let percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded(obj)");
          if (percentComplete == 100) {
            loaded_items += 1;
          }
        }
      };
      let onProgress_mtl = function (xhr) {
        if (xhr.lengthComputable) {
          let percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded(mtl)");
          if (percentComplete == 100) {
            loaded_items += 1;
          }
        }
      };
      var newobj = obj3d.clone();
      var newmtl = new MTLLoader();
      newmtl.load(
        url1 + ".mtl",
        (mtl) => {
          mtl.preload();
          const objLoader = new OBJLoader();
          objLoader.setMaterials(mtl);
          objLoader.load(
            url + ".obj",
            (root) => {
              var object = root;
              for (var k in root.children) {
                root.children[k].castShadow = true;
                root.children[k].receiveShadow = true;
              }

              var Cylinder = new THREE.Mesh(
                new THREE.CylinderGeometry(32, 32, 32, 3),
                new THREE.MeshPhongMaterial({
                  color: 0xccddff,
                  specular: 0xffffff,
                  emissive: 0xccddff,
                  transparent: true,
                  opacity: 0.95,
                })
              );
              Cylinder.rotation.y = Math.PI / 3;
              Cylinder.position.set(0, 225, 1.925);
              var light_white = new THREE.PointLight(
                0xccddff,
                0.5,
                500 * scale
              );
              light_white.position.set(0, 225, 1.925);
              light_white.penumbra = 0.3;
              light_white.castShadow = true;
              light_white.shadow.mapSize.width = 2048;
              light_white.shadow.mapSize.height = 2048;
              light_white.shadow.camera.far = 500 * scale * 1 /*ufo_scale/100*/;
              light_white.shadow.camera.near = 32 * scale * 1 /*ufo_scale/100*/;
              object.position.set(0, 0, 0);
              object.scale.set(0.2, 0.2, 0.2);
              //newobj.add(object);
              newobj.add(Cylinder);
              newobj.add(light_white);
              newobj.scale.set(scale, scale, scale);
            },
            onProgress_obj
          );
        },
        onProgress_mtl
      );
      return newobj;
    }

    function obj_lighting(url, size, x, y, z, name) {
      size = size * 0.8;
      var startTexture = THREE.ImageUtils.loadTexture(url);
      var starBall = new THREE.Mesh(
        new THREE.SphereGeometry(size, 100, 100),
        new THREE.MeshPhongMaterial({
          emissive: 0xffffff,
          emissiveMap: startTexture,
        })
      );
      star_radius[name] = size * 1.02;
      starBall.position.set(x, y, z);
      return starBall;
    }
    function obj(url, size, x, y, z, name) {
      size = size * 0.8;
      var startTexture = THREE.ImageUtils.loadTexture(url);
      if (name == "star3") {
        var starBall = new THREE.Mesh(
          new THREE.SphereGeometry(size, 50, 50),
          new THREE.MeshPhongMaterial({
            map: startTexture,
            normalMap: new THREE.TextureLoader().load(
              "./texture/EarthNormal.png",
              function (texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
              }
            ),
          })
        );
      } else if (name == "star2") {
        //console.log(name)
        startTexture.wrapS = startTexture.wrapT = THREE.RepeatWrapping;
        startTexture.repeat.set(3, 3);
        var starBall = new THREE.Mesh(
          new THREE.SphereGeometry(size, 50, 50),
          new THREE.MeshPhongMaterial({
            map: startTexture,
            normalMap: new THREE.TextureLoader().load(
              "./texture/normal1.jpg",
              function (texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(3, 3);
              }
            ),
          })
        );
      } else if (size > 10 && size < 18 && size != 12) {
        if (name == "star7") {
          startTexture.wrapS = startTexture.wrapT = THREE.RepeatWrapping;
          startTexture.repeat.set(3, 3);
        }
        var starBall = new THREE.Mesh(
          new THREE.SphereGeometry(size, 50, 50),
          new THREE.MeshPhongMaterial({
            map: startTexture,
            normalMap: new THREE.TextureLoader().load(
              "./texture/normal.jpg",
              function (texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
              }
            ),
          })
        );
      } else if (size < 18 && name != "starlite6") {
        //console.log(name)
        var starBall = new THREE.Mesh(
          new THREE.SphereGeometry(size, 50, 50),
          new THREE.MeshPhongMaterial({
            map: startTexture,
            normalMap: new THREE.TextureLoader().load(
              "./texture/normal1.jpg",
              function (texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
              }
            ),
          })
        );
      } else if (name == "starlite6") {
        //console.log(name)
        startTexture.wrapS = startTexture.wrapT = THREE.RepeatWrapping;
        startTexture.repeat.set(5, 5);
        var starBall = new THREE.Mesh(
          new THREE.SphereGeometry(size, 50, 50),
          new THREE.MeshPhongMaterial({
            map: startTexture,
            normalMap: new THREE.TextureLoader().load(
              "./texture/normal2.jpg",
              function (texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(30, 30);
              }
            ),
          })
        );
      } else if (size < 18) {
        var starBall = new THREE.Mesh(
          new THREE.SphereGeometry(size, 50, 50),
          new THREE.MeshPhongMaterial({
            map: startTexture,
            normalMap: new THREE.TextureLoader().load(
              "./texture/normal3.jpg",
              function (texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
              }
            ),
          })
        );
      } else {
        var starBall = new THREE.Mesh(
          new THREE.SphereGeometry(size, 50, 50),
          new THREE.MeshPhongMaterial({
            map: startTexture,
            normalMap: new THREE.TextureLoader().load(
              "./texture/normal4.jpg",
              function (texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
              }
            ),
          })
        );
      }
      star_radius[name] = size;
      starBall.position.set(x, y, z);
      return starBall;
    }

    function ring1(url, size, width, x, y, z) {
      size = size * 0.8;
      var startTexture = THREE.ImageUtils.loadTexture(url);
      var r = new THREE.RingGeometry(size, size + width, size * 10);
      var pos = r.attributes.position;
      var v3 = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++) {
        v3.fromBufferAttribute(pos, i);
        r.attributes.uv.setXY(i, v3.length() < size + 1 ? 0 : 1, 1);
      }
      var starBall = new THREE.Mesh(
        r,
        new THREE.MeshBasicMaterial({
          color: 0xffeecc,
          map: startTexture,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.2,
        })
      );
      starBall.rotation.x = -Math.PI / 2;
      starBall.rotation.y = -Math.PI / 12;
      starBall.position.set(x, y, z);
      return starBall;
    }
    function ring2(url, size, width, x, y, z) {
      size = size * 0.8;
      var startTexture = THREE.ImageUtils.loadTexture(url);
      var r = new THREE.RingGeometry(size, size + width, size * 10);
      var pos = r.attributes.position;
      var v3 = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++) {
        v3.fromBufferAttribute(pos, i);
        r.attributes.uv.setXY(i, v3.length() < size + 1 ? 0 : 1, 1);
      }
      var starBall = new THREE.Mesh(
        r,
        new THREE.MeshBasicMaterial({
          map: startTexture,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.1,
        })
      );
      starBall.rotation.x = -Math.PI / 2;
      starBall.rotation.y = -Math.PI / 6;
      starBall.position.set(x, y, z);
      return starBall;
    }

    function getMousePosition() {
      var x = document.getElementById("aiming1").offsetLeft + 10;
      var y = document.getElementById("aiming1").offsetTop + 10;
      return { x: x, y: y };
    }
    function mouseMove(e) {
      mouse.x =
        ((document.getElementById("aiming1").offsetLeft + 10) /
          window.innerWidth) *
          2 -
        1;
      mouse.y =
        -(
          (document.getElementById("aiming1").offsetTop + 10) /
          window.innerHeight
        ) *
          2 +
        1;

      document.getElementById("aiming1").style.left = e.clientX - 10 + "px";
      document.getElementById("aiming1").style.top = e.clientY - 10 + "px";
      if (esc)
        var mouseP = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      else var mouseP = getMousePosition();
      if (mouseP["y"] / window.innerHeight < 0.5) {
        up = 0.5 - mouseP["y"] / window.innerHeight;
      } else {
        up = 0;
      }
      if (mouseP["y"] / window.innerHeight > 0.62) {
        down = mouseP["y"] / window.innerHeight - 0.62;
      } else {
        down = 0;
      }
      if (mouseP["x"] / window.innerWidth < 0.47) {
        left = 0.47 - mouseP["x"] / window.innerWidth;
      } else {
        left = 0;
      }
      if (mouseP["x"] / window.innerWidth > 0.53) {
        right = mouseP["x"] / window.innerWidth - 0.53;
      } else {
        right = 0;
      }
    }

    function bounder_detect() {
      var distance =
        Math.sqrt(
          cameraPosition.x * cameraPosition.x +
            cameraPosition.z * cameraPosition.z
        ) - 1500;
      var dir = vec
        .clone()
        .set(0 - cameraPosition.x, 0, 0 - cameraPosition.z)
        .normalize();
      if (distance > 0) {
        selected_object = false;
        cameraPosition.z += distance * dir.z;
        cameraPosition.x += distance * dir.x;
      }
      cameraPosition.y = Math.max(
        -508 + 0.55 * ufo_scale,
        Math.min(400, cameraPosition.y)
      );
      if (
        crash_detect(ufo, sun, "sun") &&
        crash_detect(ufo, star1, "star1") &&
        crash_detect(ufo, star2, "star2") &&
        crash_detect(ufo, star3, "star3") &&
        crash_detect(ufo, starlite3, "starlite3") &&
        crash_detect(ufo, star4, "star4") &&
        crash_detect(ufo, star5, "star5") &&
        crash_detect(ufo, star6, "star6") &&
        crash_detect(ufo, starlite6, "starlite6") &&
        crash_detect(ufo, starlite61, "starlite61") &&
        crash_detect(ufo, starlite62, "starlite62") &&
        crash_detect(ufo, starlite63, "starlite63") &&
        crash_detect(ufo, starlite64, "starlite64") &&
        crash_detect(ufo, starlite65, "starlite65") &&
        crash_detect(ufo, star7, "star7") &&
        crash_detect(ufo, star8, "star8") &&
        crash_detect(ufo, star9, "star9")
      ) {
        return false;
      } else {
        return true;
      }
    }
    function crash_detect(a, b, i) {
      if (star_radius[i] + 1 > a.position.distanceTo(b.position)) {
        hit_direction
          .set(
            a.position.x - b.position.x,
            a.position.y - b.position.y,
            a.position.z - b.position.z
          )
          .normalize();
        return false;
      } else {
        return true;
      }
    }

    function hit_detect() {
      if (!hit_open) return false;
      var detect_obj = [all_obj3];
      raycaster.near = 0.1;
      raycaster.far = 0.5 * ufo_scale;
      var local = vec
        .clone()
        .set(ufo.position.x, ufo.position.y + 0.2 * ufo_scale, ufo.position.z);
      var all_direct1 = [
        vec.clone().set(1, 0, 0),
        vec.clone().set(0.707, 0, 0.707),
        vec.clone().set(0, 0, 1),
        vec.clone().set(-1, 0, 0),
        vec.clone().set(-0.707, 0, -0.707),
        vec.clone().set(0, 0, -1),
        vec.clone().set(0.707, 0, -0.707),
        vec.clone().set(-0.707, 0, 0.707),
      ];
      for (var i = 0; i < all_direct1.length; i++) {
        raycaster.set(local, all_direct1[i].normalize());
        var hit_face = raycaster.intersectObjects(detect_obj, true);
        if (hit_face.length > 0) {
          if (hit_face[0].distance < 0.5 * ufo_scale) {
            hit_direction.set(
              local.x - hit_face[0].point.x,
              local.y - hit_face[0].point.y,
              local.z - hit_face[0].point.z
            );
            return true;
          }
        }
      }
      var all_direct2 = [vec.clone().set(0, 1, 0), vec.clone().set(0, -1, 0)];
      for (var i = 0; i < all_direct2.length; i++) {
        raycaster.set(local, all_direct2[i].normalize());
        var hit_face = raycaster.intersectObjects(detect_obj, true);
        if (hit_face.length > 0) {
          if (hit_face[0].distance < 0.3 * ufo_scale) {
            hit_direction.set(
              local.x - hit_face[0].point.x,
              local.y - hit_face[0].point.y,
              local.z - hit_face[0].point.z
            );
            return true;
          }
        }
      }
      return false;
    }

    function onMouseClick(event) {
      if (document.getElementById("content").style.display == "none" && !esc) {
        raycaster1.setFromCamera(mouse, camera);
        raycaster1.near = 0.1;
        raycaster1.far = 10000;
        var intersects = raycaster1.intersectObjects(scene.children, true);
        for (var i = 0; i < intersects.length; i++) {
          if (
            intersects[i].object.type != "Sprite" &&
            intersects[i].object.name != "ring" &&
            intersects[i].object.name != "Sky"
          )
            break;
        }
        if (i < intersects.length) {
          arrived = 50;
          selected_object = intersects[i];
          catchspeed = 0;
          t_in = true;
        } else {
          selected_object = false;
          t_in = false;
        }
      }
    }

    window.addEventListener("mousedown", onMouseClick, false);

    function operation_method_1(delta) {
      if (!ufo || !ufo.children || !ufo.children[10]) return;
      if (bounder_detect() && hit_frame < 490) {
        hit_frame = 500;
        chaseing_frame = 0;
      }
      if (hit_frame > 0) {
        moveForward = moveLeft = moveRight = moveBackward = false;
        currentSpeedForward = 0;
        currentSpeedRight = 0;
        cameraPosition.x += (hit_direction.x * hit_frame * rotatespeed) / 10000;
        cameraPosition.y += (hit_direction.y * hit_frame * rotatespeed) / 10000;
        cameraPosition.z += (hit_direction.z * hit_frame * rotatespeed) / 10000;

        ufo.rotation.x =
          Math.cos((hit_frame * Math.PI) / 7) * (hit_frame / 3000);
        ufo.rotation.z =
          Math.sin((hit_frame * Math.PI) / 7) * (hit_frame / 3000);
        ufo.children[1].scale.set(0, 0);
        ufo.children[1].material.opacity = 0;
        ufo.children[1].position.y = 0.15;

        ufo.children[10].material.color.set(0xff2222);
        ufo.children[10].material.specular.set(0xff2222);
        ufo.children[10].material.emissive.set(0xff2222);

        hit_frame -= fps_speed;
        speed = -speed / 20 + speed;
        selected_object = false;
      } else {
        ufo.rotation.x = 0;
        ufo.children[10].material.color.set(0x44e0ff);
        ufo.children[10].material.specular.set(0x44e0ff);
        ufo.children[10].material.emissive.set(0x44e0ff);
      }
      if (document.getElementById("content").style.display == "none") {
        esc = false;
      }
      if (fast) maxSpeed = 0.6 * fps_speed;
      else maxSpeed = Math.max(maxSpeed - 0.03 * fps_speed, 0.3 * fps_speed);

      if ((moveForward || moveBackward || moveRight || moveLeft) && !fast) {
        ufo.children[1].scale.y =
          ((0.4 - ufo.children[1].scale.y) / 50) * fps_speed +
          ufo.children[1].scale.y;
        ufo.children[1].material.opacity =
          ((0.8 - ufo.children[1].material.opacity) / 50) * fps_speed +
          ufo.children[1].material.opacity;
        ufo.children[1].position.y =
          ((-0.09 - ufo.children[1].position.y) / 50) * fps_speed +
          ufo.children[1].position.y;
        speed = (2 - speed) / 50 + speed;
      } else if (
        (moveForward || moveBackward || moveRight || moveLeft) &&
        fast
      ) {
        ufo.children[1].scale.y =
          ((0.6 - ufo.children[1].scale.y) / 50) * fps_speed +
          ufo.children[1].scale.y;
        ufo.children[1].material.opacity =
          ((0.95 - ufo.children[1].material.opacity) / 50) * fps_speed +
          ufo.children[1].material.opacity;
        ufo.children[1].position.y =
          ((-0.15 - ufo.children[1].position.y) / 50) * fps_speed +
          ufo.children[1].position.y;
        speed = (4 - speed) / 50 + speed;
      } else {
        ufo.children[1].scale.y =
          ((0.25 - ufo.children[1].scale.y) / 50) * fps_speed +
          ufo.children[1].scale.y;
        ufo.children[1].material.opacity =
          ((0.7 - ufo.children[1].material.opacity) / 50) * fps_speed +
          ufo.children[1].material.opacity;
        ufo.children[1].position.y =
          ((-0.04 - ufo.children[1].position.y) / 50) * fps_speed +
          ufo.children[1].position.y;
        speed = (1 - speed) / 50 + speed;
      }
      // Mouse Move

      if (moveForward && !moveBackward) {
        if (!Forward && currentSpeedForward != 0) {
          cameraPosition.z -= cameraDirection.z * currentSpeedForward;
          cameraPosition.y -= cameraDirection.y * currentSpeedForward;
          cameraPosition.x -= cameraDirection.x * currentSpeedForward;
          currentSpeedForward = Math.max(0, currentSpeedForward - delta * acc);
        } else {
          cameraPosition.z += cameraDirection.z * currentSpeedForward;
          cameraPosition.y += cameraDirection.y * currentSpeedForward;
          cameraPosition.x += cameraDirection.x * currentSpeedForward;
          currentSpeedForward = Math.min(
            maxSpeed,
            currentSpeedForward + delta * acc
          );
          Forward = true;
        }
      } else if (moveBackward && !moveForward) {
        if (Forward && currentSpeedForward != 0) {
          cameraPosition.z += cameraDirection.z * currentSpeedForward;
          cameraPosition.y += cameraDirection.y * currentSpeedForward;
          cameraPosition.x += cameraDirection.x * currentSpeedForward;
          currentSpeedForward = Math.max(0, currentSpeedForward - delta * acc);
        } else {
          cameraPosition.z -= cameraDirection.z * currentSpeedForward;
          cameraPosition.y -= cameraDirection.y * currentSpeedForward;
          cameraPosition.x -= cameraDirection.x * currentSpeedForward;
          currentSpeedForward = Math.min(
            maxSpeed,
            currentSpeedForward + delta * acc
          );
          Forward = false;
        }
      }

      if (moveRight && !moveLeft) {
        if (!Right && currentSpeedRight != 0) {
          cameraPosition.x += cameraDirection.z * currentSpeedRight;
          cameraPosition.z -= cameraDirection.x * currentSpeedRight;
          currentSpeedRight = Math.max(0, currentSpeedRight - delta * acc);
        } else {
          cameraPosition.x -= cameraDirection.z * currentSpeedRight;
          cameraPosition.z += cameraDirection.x * currentSpeedRight;
          currentSpeedRight = Math.min(
            maxSpeed / 2,
            currentSpeedRight + delta * acc
          );
          Right = true;
        }
      } else if (moveLeft && !moveRight) {
        if (Right && currentSpeedRight != 0) {
          cameraPosition.x -= cameraDirection.z * currentSpeedRight;
          cameraPosition.z += cameraDirection.x * currentSpeedRight;
          currentSpeedRight = Math.max(0, currentSpeedRight - delta * acc);
        } else {
          cameraPosition.x += cameraDirection.z * currentSpeedRight;
          cameraPosition.z -= cameraDirection.x * currentSpeedRight;
          currentSpeedRight = Math.min(
            maxSpeed / 2,
            currentSpeedRight + delta * acc
          );
          Right = false;
        }
      }
      if ((!moveBackward && !moveForward) || (moveBackward && moveForward)) {
        if (Forward) {
          cameraPosition.z += cameraDirection.z * currentSpeedForward;
          cameraPosition.y += cameraDirection.y * currentSpeedForward;
          cameraPosition.x += cameraDirection.x * currentSpeedForward;
          currentSpeedForward = Math.max(0, currentSpeedForward - delta * acc);
        } else {
          cameraPosition.z -= cameraDirection.z * currentSpeedForward;
          cameraPosition.y -= cameraDirection.y * currentSpeedForward;
          cameraPosition.x -= cameraDirection.x * currentSpeedForward;
          currentSpeedForward = Math.max(0, currentSpeedForward - delta * acc);
        }
      }
      if ((!moveRight && !moveLeft) || (moveRight && moveLeft)) {
        if (Right) {
          cameraPosition.x -= cameraDirection.z * currentSpeedRight;
          cameraPosition.z += cameraDirection.x * currentSpeedRight;
          currentSpeedRight = Math.max(0, currentSpeedRight - delta * acc);
        } else {
          cameraPosition.x += cameraDirection.z * currentSpeedRight;
          cameraPosition.z -= cameraDirection.x * currentSpeedRight;
          currentSpeedRight = Math.max(0, currentSpeedRight - delta * acc);
        }
      }
      angleX += (left / 15 / Math.PI - right / 15 / Math.PI) * fps_speed;
      cameraDirection.x -= (Math.sin(angleX) * ufo_scale) / 2;
      cameraDirection.z -= (Math.cos(angleX) * ufo_scale) / 2;

      if (cameraDirection.y < 0.85 * ufo_scale && !scaling) {
        angleY += (up / 600 / Math.PI) * fps_speed * ufo_scale;
      }
      if (cameraDirection.y > -0.8 * ufo_scale && !scaling) {
        angleY -= (down / 500 / Math.PI) * fps_speed * ufo_scale;
      }
      //console.log(angleY)
      cameraDirection.y = Math.sin(angleY) * 60;
      cameraDirection.setLength(2.4 * ufo_scale);

      if (
        add_solar &&
        selected_object &&
        plant_name.includes(selected_object.object.name) &&
        document.getElementById("content").style.display == "none"
      ) {
        safe_dis = 1 * ufo_scale;
        if (selected_object.object.name == "sun") safe_dis = 10;

        chaseing_frame = 50;
        ufo.children[10].material.color.set(0xffff33);
        ufo.children[10].material.specular.set(0xffff33);
        ufo.children[10].material.emissive.set(0xffff33);
        catchspeed = Math.min(
          catchspeed + 0.01 * fps_speed,
          1.2 * fps_speed * ufo_scale
        );
        var delx = selected_object.object.position.x - cameraPosition.x;
        var dely = selected_object.object.position.y - cameraPosition.y;
        var delz = selected_object.object.position.z - cameraPosition.z;
        var di = vec.clone().set(delx, dely, delz).normalize();
        chasing.set(
          delx - di.x * (star_radius[selected_object.object.name] + safe_dis),
          dely - di.y * (star_radius[selected_object.object.name] + safe_dis),
          delz - di.z * (star_radius[selected_object.object.name] + safe_dis)
        );
        if (chasing.distanceTo(start_point) < 60) {
          t_in = false;
        }
        if (t_in) {
          ufo_starlight = Math.min(ufo_starlight + 0.0002 * fps_speed, 0.08);
          ufo.children[3].scale.set(
            ufo_starlight * 5,
            (ufo_starlight * 25) / 6
          );
          ufo.children[11].intensity = ufo_starlight * 20 - 0.5;
          ufo.children[12].intensity = ufo_starlight * 20 + 1;
          ufo.children[1].scale.y =
            ((0.9 - ufo.children[1].scale.y) / 50) * fps_speed +
            ufo.children[1].scale.y;
          ufo.children[1].material.opacity =
            ((1 - ufo.children[1].material.opacity) / 50) * fps_speed +
            ufo.children[1].material.opacity;
          ufo.children[1].position.y =
            ((-0.2 - ufo.children[1].position.y) / 50) * fps_speed +
            ufo.children[1].position.y;
          tranfer_speed = Math.min(tranfer_speed + 1 * fps_speed, 10 / speed);
        } else {
          ufo_starlight = Math.max(ufo_starlight - 0.0002 * fps_speed, 0.06);
          ufo.children[3].scale.set(
            ufo_starlight * 5,
            (ufo_starlight * 25) / 6
          );
          ufo.children[11].intensity = ufo_starlight * 20 - 0.5;
          ufo.children[12].intensity = ufo_starlight * 20 + 1;
          ufo.children[1].scale.y =
            ((0.25 - ufo.children[1].scale.y) / 100) * fps_speed +
            ufo.children[1].scale.y;
          ufo.children[1].material.opacity =
            ((0.7 - ufo.children[1].material.opacity) / 100) * fps_speed +
            ufo.children[1].material.opacity;
          ufo.children[1].position.y =
            ((-0.04 - ufo.children[1].position.y) / 100) * fps_speed +
            ufo.children[1].position.y;
          tranfer_speed = Math.max(tranfer_speed - 0.1 * fps_speed, 1);
          arrived -= 1;
        }
        if (selected_object.object.name == "starlite3") {
          cameraPosition.x += (chasing.x * catchspeed) / 10;
          cameraPosition.y += (chasing.y * catchspeed) / 10;
          cameraPosition.z += (chasing.z * catchspeed) / 10;
        } else {
          cameraPosition.x += (chasing.x * catchspeed) / 20;
          cameraPosition.y += (chasing.y * catchspeed) / 20;
          cameraPosition.z += (chasing.z * catchspeed) / 20;
        }
      } else if (
        arrived > 0 &&
        selected_object &&
        document.getElementById("content").style.display == "none"
      ) {
        ////console.log(selected_object.point)
        safe_dis = 1 * ufo_scale;
        chaseing_frame = 50;
        ufo.children[10].material.color.set(0xffff33);
        ufo.children[10].material.specular.set(0xffff33);
        ufo.children[10].material.emissive.set(0xffff33);
        catchspeed = Math.min(catchspeed + 0.01 * fps_speed, 1.2 * fps_speed);
        var delx =
          Math.max(-1500, Math.min(1500, selected_object.point.x)) -
          cameraPosition.x;
        var dely = selected_object.point.y - cameraPosition.y;
        var delz =
          Math.max(-1500, Math.min(1500, selected_object.point.z)) -
          cameraPosition.z;
        var di = vec.clone().set(delx, dely, delz).normalize();
        chasing.set(
          delx - di.x * safe_dis,
          dely - di.y * safe_dis,
          delz - di.z * safe_dis
        );
        if (chasing.distanceTo(start_point) < 50) {
          t_in = false;
        }
        if (t_in) {
          ufo_starlight = Math.min(ufo_starlight + 0.0002 * fps_speed, 0.08);
          ufo.children[3].scale.set(
            ufo_starlight * 5,
            (ufo_starlight * 25) / 6
          );
          ufo.children[11].intensity = ufo_starlight * 20 - 0.5;
          ufo.children[12].intensity = ufo_starlight * 20 + 1;
          ufo.children[1].scale.y =
            ((0.9 - ufo.children[1].scale.y) / 50) * fps_speed +
            ufo.children[1].scale.y;
          ufo.children[1].material.opacity =
            ((1 - ufo.children[1].material.opacity) / 50) * fps_speed +
            ufo.children[1].material.opacity;
          ufo.children[1].position.y =
            ((-0.2 - ufo.children[1].position.y) / 50) * fps_speed +
            ufo.children[1].position.y;
          tranfer_speed = Math.min(tranfer_speed + 1 * fps_speed, 10 / speed);
        } else {
          ufo_starlight = Math.max(ufo_starlight - 0.0002 * fps_speed, 0.06);
          ufo.children[3].scale.set(
            ufo_starlight * 5,
            (ufo_starlight * 25) / 6
          );
          ufo.children[11].intensity = ufo_starlight * 20 - 0.5;
          ufo.children[12].intensity = ufo_starlight * 20 + 1;
          ufo.children[1].scale.y =
            ((0.25 - ufo.children[1].scale.y) / 100) * fps_speed +
            ufo.children[1].scale.y;
          ufo.children[1].material.opacity =
            ((0.7 - ufo.children[1].material.opacity) / 100) * fps_speed +
            ufo.children[1].material.opacity;
          ufo.children[1].position.y =
            ((-0.04 - ufo.children[1].position.y) / 100) * fps_speed +
            ufo.children[1].position.y;
          tranfer_speed = Math.max(tranfer_speed - 0.1 * fps_speed, 1);
          arrived -= 1;
        }

        cameraPosition.x += (chasing.x * catchspeed) / 50;
        cameraPosition.y += (chasing.y * catchspeed) / 50;
        cameraPosition.z += (chasing.z * catchspeed) / 50;
      } else {
        if (hit_frame <= 0) {
          ufo.children[10].material.color.set(0x44e0ff);
          ufo.children[10].material.specular.set(0x44e0ff);
          ufo.children[10].material.emissive.set(0x44e0ff);
          cameraPosition.x +=
            ((chasing.x * catchspeed) / 2500) * chaseing_frame;
          cameraPosition.y +=
            ((chasing.y * catchspeed) / 2500) * chaseing_frame;
          cameraPosition.z +=
            ((chasing.z * catchspeed) / 2500) * chaseing_frame;
          if (chaseing_frame > 0) chaseing_frame -= fps_speed;
          else chaseing_frame = 0;
        }
        ufo_starlight = Math.max(ufo_starlight - 0.0002 * fps_speed, 0.06);
        ufo.children[3].scale.set(ufo_starlight * 5, (ufo_starlight * 25) / 6);
        ufo.children[11].intensity = ufo_starlight * 20 - 0.5;
        ufo.children[12].intensity = ufo_starlight * 20 + 1;
        ufo.children[1].scale.set(
          ((0.05 - ufo.children[1].scale.x) / 100) * fps_speed +
            ufo.children[1].scale.x,
          (0.25 - ufo.children[1].scale.y) / 100 + ufo.children[1].scale.y
        );
        ufo.children[1].material.opacity =
          ((0.7 - ufo.children[1].material.opacity) / 100) * fps_speed +
          ufo.children[1].material.opacity;
        ufo.children[1].position.y =
          ((-0.04 - ufo.children[1].position.y) / 100) * fps_speed +
          ufo.children[1].position.y;
        tranfer_speed = Math.max(tranfer_speed - 0.1 * fps_speed, 1);
      }

      var follow = 1;
      //ufo.position.set((cameraPosition.x-ufo.position.x)/follow+ufo.position.x, (cameraPosition.y-ufo.position.y)/follow+ufo.position.y, (cameraPosition.z-ufo.position.z)/follow+ufo.position.z);
      ufo.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
      ufo.rotation.y += (0.01 / Math.PI) * speed * tranfer_speed * fps_speed;
      ufo.position.y += Math.sin(count * 60) * 0.01 * speed * ufo_scale;

      //camera.position.set(cameraPosition.x - cameraDirection.x, cameraPosition.y - cameraDirection.y + 0.6 * ufo_scale, cameraPosition.z - cameraDirection.z);
      camera.position.set(
        (cameraPosition.x - cameraDirection.x - camera.position.x) / follow +
          camera.position.x,
        (cameraPosition.y -
          cameraDirection.y +
          0.6 * ufo_scale -
          camera.position.y) /
          follow +
          camera.position.y,
        (cameraPosition.z - cameraDirection.z - camera.position.z) / follow +
          camera.position.z
      );
      camera.lookAt(
        cameraPosition.x,
        cameraPosition.y + 0.6 * ufo_scale,
        cameraPosition.z
      );
    }

    function generate_meteoriteObject3D(size) {
      size = size * (Math.random() + 0.7);
      var osize = size;

      var meteoriteObject3D = meteorite_Object3D.clone();

      var x, y, z;
      x = (Math.random() - 0.5) * 8000;
      y = Math.random() * 4000 - 500;
      z =
        Math.sqrt(7999 * 7999 - x * x - y * y) * (Math.random() > 0.5 ? 1 : -1);

      var v1 = vec
        .clone()
        .set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)
        .normalize();
      while (
        (v1.y < 0 && y < 500) ||
        vec.clone().set(-x, -y, -z).normalize().dot(v1) < 0.85 ||
        vec.clone().set(-x, -y, -z).normalize().dot(v1) > 0.851 ||
        (z < 0 && v1.z < 0)
      ) {
        v1 = vec
          .clone()
          .set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)
          .normalize();
      }
      var x1 = x;
      var y1 = y;
      var z1 = z;

      for (var i = 0; i < 2; i++) {
        if (i % 2 == 0) var meteorite = material.clone();
        else var meteorite = materialr.clone();
        meteorite.position.set(x - x1, y - y1, z - z1);
        meteorite.scale.set(size * 1.15, size * 1.15, 1);
        meteoriteObject3D.add(meteorite);
        x = x - (size * v1.x) / 3;
        y = y - (size * v1.y) / 3;
        z = z - (size * v1.z) / 3;
      }
      while (size > 1) {
        var meteorite = material.clone();
        var msize = Math.max(0.6, Math.pow(size / osize, 0.25));
        meteorite.scale.set(size * msize, size * msize, 1);
        meteorite.position.set(x - x1, y - y1, z - z1);
        meteoriteObject3D.add(meteorite);
        var meteorite = material1.clone();
        meteorite.scale.set(size, size, 1);
        meteorite.position.set(x - x1, y - y1, z - z1);
        meteoriteObject3D.add(meteorite);

        x = x - (size * v1.x) / 2.8;
        y = y - (size * v1.y) / 2.8;
        z = z - (size * v1.z) / 2.8;
        size *= 0.985;
      }
      meteoriteObject3D.position.set(x1, y1, z1);
      return [meteoriteObject3D, v1];
    }

    function meteorite_move(meteorite1) {
      if (meteorite1[0].position.distanceTo(start_point) > 8000) {
        scene.remove(meteorite1[0]);
        return true;
      }
      meteorite1[0].position.x += meteorite1[1].x * 3 * fps_speed;
      meteorite1[0].position.y += meteorite1[1].y * 3 * fps_speed;
      meteorite1[0].position.z += meteorite1[1].z * 3 * fps_speed;
      return false;
    }
    
    let star_frame = 0;
    function animate() {
      if (esc) {
        document.querySelector("body").style.cursor =
          "url(./img/cursor.png),default";
        document.getElementById("aiming1").style.display = "none";
      } else {
        document.querySelector("body").style.cursor = "none";
        document.getElementById("aiming1").style.display = "block";
      }

      var delta = clock.getDelta();    
      requestAnimationFrame(animate);
      if (loaded_items > 0 && loaded_items == load_items) hide_loading();
      else return
      customUniforms.time.value += delta;
      // customUniforms.baseSpeed.value = controls.baseSpeed;
      // customUniforms.noiseScale.value = controls.noiseScale;
      // customUniforms.bumpSpeed.value = controls.bumpSpeed;
      // customUniforms.bumpScale.value = controls.bumpScale;
      // customUniforms.bumpRepeat.value = controls.bumpRepeat;
      // customUniforms.noiseRepeat.value = controls.noiseRepeat;
      timeStamp += delta;
      if (timeStamp > singleFrameTime) {
        //stats.update();
        if (selected_object && selected_object.object.name == "star3") {
          follow_frame1 += 1;
        } else {
          follow_frame1 = 0;
        }
        if (selected_object && selected_object.object.name == "star4") {
          follow_frame2 += 1;
        } else {
          follow_frame2 = 0;
        }
        if (selected_object && selected_object.object.name == "star6") {
          follow_frame3 += 1;
        } else {
          follow_frame3 = 0;
        }
        if (follow_frame1 > FPS * 5) {
          go_island();
        } else if (follow_frame2 > FPS * 5) {
          go_alian_base();
        } else if (follow_frame3 > FPS * 5) {
          go_lightning();
        }
        if (meteorites.length < 10) {
          var meteorite1 = generate_meteoriteObject3D(8);
          meteorites.push(meteorite1);
          scene.add(meteorite1[0]);
        }
        for (var met in meteorites) {
          if (meteorite_move(meteorites[met])) meteorites.splice(met, 1);
        }

        var rotate = angle * Math.PI * rotatespeed;

        angle += 0.0005;
        if (add_solar) {
          sun.rotation.y -= ((0.005 / Math.PI) * rotatespeed) / 5;
          var position1 = (2 * rotate) / 5;
          star1.rotateOnWorldAxis(
            vec.clone().set(-1, 1, 0).normalize(),
            ((0.2 / Math.PI) * rotatespeed) / 5
          );
          star1.position.x = Math.sin(position1) * 180;
          star1.position.z = Math.cos(position1) * 180;

          var position2 = (1.8 * rotate) / 5;
          star2.rotateOnWorldAxis(
            vec.clone().set(0, 2, 0).normalize(),
            ((0.02 / Math.PI) * rotatespeed) / 5
          );
          star2.position.x = Math.sin(position2) * 240;
          star2.position.z = Math.cos(position2) * 240;

          var position3 = (1.5 * rotate) / 5;
          star3.rotateOnWorldAxis(
            vec.clone().set(0.2, 1, 0).normalize(),
            ((0.04 / Math.PI) * rotatespeed) / 5
          );
          star3.position.x = Math.sin(position3) * 320;
          star3.position.z = Math.cos(position3) * 320;
          var position3 = (10 * rotate) / 5;
          starlite3.rotateOnWorldAxis(
            vec.clone().set(0.1, 1, 0).normalize(),
            ((0.4 / Math.PI) * rotatespeed) / 3 / 5
          );
          starlite3.position.x =
            Math.sin(position3 / 2) * 19 + star3.position.x;
          starlite3.position.z =
            Math.cos(position3 / 2) * 19 + star3.position.z;
          starlite3.position.y =
            Math.sin(position3 / 2) * 21 + star3.position.y;

          var position4 = (0.85 * rotate) / 5;
          star4.rotateOnWorldAxis(
            vec.clone().set(0, 1, 0).normalize(),
            ((0.06 / Math.PI) * rotatespeed) / 5
          );
          star4.position.x = Math.sin(position4) * 780;
          star4.position.z = Math.cos(position4) * 780;
          ring4.rotateOnWorldAxis(
            vec.clone().set(0, 1, 0).normalize(),
            ((((0.7 * 0.0005) / Math.PI) * rotatespeed) / 5) * 10
          );
          ring4.position.x = Math.sin(position4) * 780;
          ring4.position.z = Math.cos(position4) * 780;

          var position5 = (1.3 * rotate) / 5;
          star5.rotateOnWorldAxis(
            vec.clone().set(1, 4, 1).normalize(),
            ((0.03 / Math.PI) * rotatespeed) / 5
          );
          star5.position.x = Math.sin(position5) * 420;
          star5.position.z = Math.cos(position5) * 420;

          var position6 = (1.1 * rotate) / 5;
          star6.rotateOnWorldAxis(
            vec.clone().set(0, 5, 0).normalize(),
            ((0.02 / Math.PI) * rotatespeed) / 5
          );
          star6.position.x = Math.sin(position6) * 600;
          star6.position.z = Math.cos(position6) * 600;
          position6 = (2 * rotate) / 5;
          starlite6.rotateOnWorldAxis(
            vec.clone().set(0.1, 1, 0.3).normalize(),
            ((0.2 / Math.PI) * rotatespeed) / 50
          );
          starlite6.position.x = Math.sin(position6) * 50 + star6.position.x;
          starlite6.position.z = Math.cos(position6) * 50 + star6.position.z;
          starlite6.position.y = Math.sin(position6) * 40 + star6.position.y;

          starlite61.rotateOnWorldAxis(
            vec.clone().set(0.5, 1, 0.2).normalize(),
            ((0.2 / Math.PI) * rotatespeed) / 50
          );
          starlite61.position.x =
            Math.sin(position6 * 2) * 40 + star6.position.x;
          starlite61.position.z =
            Math.cos(position6 * 2) * 40 + star6.position.z;
          starlite61.position.y =
            Math.sin(position6 * 2) * 35 + star6.position.y;

          starlite62.rotateOnWorldAxis(
            vec.clone().set(0.2, 1, 0.6).normalize(),
            ((0.2 / Math.PI) * rotatespeed) / 50
          );
          starlite62.position.x =
            Math.sin(position6 * 1.2) * 55 + star6.position.x;
          starlite62.position.z =
            Math.cos(position6 * 1.2) * 55 + star6.position.z;
          starlite62.position.y =
            Math.sin(position6 * 1.2) * 45 + star6.position.y;

          starlite63.rotateOnWorldAxis(
            vec.clone().set(0.1, 1, 0.5).normalize(),
            ((0.2 / Math.PI) * rotatespeed) / 50
          );
          starlite63.position.x =
            Math.sin(position6 * 1.5) * 60 + star6.position.x;
          starlite63.position.z =
            Math.cos(position6 * 1.5) * 60 + star6.position.z;
          starlite63.position.y =
            Math.sin(position6 * 1.5) * 50 + star6.position.y;

          starlite64.rotateOnWorldAxis(
            vec.clone().set(0.2, 1, 0.3).normalize(),
            ((0.2 / Math.PI) * rotatespeed) / 50
          );
          starlite64.position.x =
            Math.sin(position6 * 0.8) * 65 + star6.position.x;
          starlite64.position.z =
            Math.cos(position6 * 0.8) * 65 + star6.position.z;
          starlite64.position.y =
            Math.sin(position6 * 0.8) * 55 + star6.position.y;

          starlite65.rotateOnWorldAxis(
            vec.clone().set(0.6, 1, 0.3).normalize(),
            ((0.2 / Math.PI) * rotatespeed) / 50
          );
          starlite65.position.x =
            Math.sin(position6 * 0.18) * 70 + star6.position.x;
          starlite65.position.z =
            Math.cos(position6 * 0.18) * 70 + star6.position.z;
          starlite65.position.y =
            Math.sin(position6 * 0.18) * 60 + star6.position.y;

          var position7 = (0.7 * rotate) / 5;
          star7.rotateOnWorldAxis(
            vec.clone().set(0.5, 3, 1).normalize(),
            ((0.015 / Math.PI) * rotatespeed) / 5
          );
          star7.position.x = Math.sin(position7) * 900;
          star7.position.z = Math.cos(position7) * 900;

          var position8 = (0.4 * rotate) / 5;
          star8.rotateOnWorldAxis(
            vec.clone().set(0, 1, 0).normalize(),
            ((0.1 / Math.PI) * rotatespeed) / 5
          );
          star8.position.x = Math.sin(position8) * 1050;
          star8.position.z = Math.cos(position8) * 1050;
          ring8.rotateOnWorldAxis(
            vec.clone().set(0, 1, 0).normalize(),
            ((((0.2 * 0.0005) / Math.PI) * rotatespeed) / 5) * 10
          );
          ring8.position.x = Math.sin(position7) * 900;
          ring8.position.z = Math.cos(position7) * 900;

          var position9 = (0.2 * rotate) / 5;
          star9.rotateOnWorldAxis(
            vec.clone().set(0, 10, 1).normalize(),
            ((0.01 / Math.PI) * rotatespeed) / 5
          );
          star9.position.x = Math.sin(position9) * 1200;
          star9.position.z = Math.cos(position9) * 1200;
        }

        //Ball Maving
        star_frame++;
        if (star_frame === 3) {
          for (let i = 0; i < particles.length; i++) {
            particle = particles[i];
            particle.scale.x = particle.scale.y =
             Math.sin(star_s_speed[i] * count * 200) + 3;
           const d = star_d[i];
           const ds = star_d_speed[i];
           particle.position.x += (d.x * Math.cos(ds.x * count)) / 6;
           particle.position.y += (d.y * Math.cos(ds.y * count)) / 6;
           particle.position.z += (d.z * Math.cos(ds.z * count)) / 6;
          }
          count += 0.0015 * fps_speed;
          star_frame = 0;
        }

        operation_method_1(delta);

        camera.updateProjectionMatrix();
        renderer.render(scene, camera);

        timeStamp = timeStamp % singleFrameTime;
      }
    }

    animate();
    var MyResize = function () {
      //get the new sizes
      var width = window.innerWidth;
      var height = window.innerHeight;

      //then update the renderer
      renderer.setSize(width, height);
      //and update the aspect ratio of the camera
      camera.aspect = width / height;

      //update the projection matrix given the new values
      camera.updateProjectionMatrix();

      //and finally render the scene again
      renderer.render(scene, camera);
    };
    window.addEventListener("resize", MyResize);
  </script>
  <script>
    document.querySelector("body").style.cursor =
      "url(./img/cursor.png),default";
    function hideMe() {
      $("#content").fadeOut(1000);
      $("#blocker").fadeOut(2000);
      $("#secondBlocker").delay(1200).fadeIn(1000);
    }

    function goAlianBase() {
      window.location.href = "alian_base.html";
    }
    function goIsland() {
      window.location.href = "island.html";
    }
    function goLightning() {
      window.location.href = "lightning.html";
    }
  </script>
</html>
